# generated by datamodel-codegen:
#   filename:  openapi-1.0.0.yaml

from __future__ import annotations

from typing import Any, Literal

from pydantic import BaseModel, ConfigDict, StrictBool


class Annotation(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: str


class ContentPart(Annotation):
    pass


class CreateResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    model: str
    input: str | list[InputItem]
    include: list[Includable] | None = None
    parallel_tool_calls: StrictBool = True
    store: StrictBool = True
    stream: StrictBool = False
    max_tokens: int | None = None
    temperature: float = 1
    top_p: float = 1
    n: int | None = None
    stop: str | list[str] | None = None
    presence_penalty: float | None = None
    frequency_penalty: float | None = None
    logit_bias: dict[str, Any] | None = None
    user: str | None = None
    instructions: str | None = None
    previous_response_id: str | None = None
    reasoning: Reasoning | None = None
    text: Text | None = None
    tool_choice: Literal["auto", "none"] | ToolChoice | None = None
    tools: list[Tool] | None = None
    truncation: Literal["disabled", "auto"] | None = None
    metadata: dict[str, Any] | None = None


class FileCitationAnnotation(Annotation):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Literal["file_citation"] = "file_citation"
    index: int
    file_id: str
    filename: str


class Format(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Literal["text", "json_object"]


class Function(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: str


class Includable(Annotation):
    pass


class IncompleteDetails(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    reason: Literal["max_output_tokens", "content_filter"]


class InputContentItem(Annotation):
    pass


class InputItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    role: Literal["user", "assistant", "system", "developer"]
    content: list[InputContentItem]


class InputTokensDetails(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    cached_tokens: int


class OutputItem(Annotation):
    pass


class OutputTokensDetails(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    reasoning_tokens: int


class RankingOptions(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    ranker: Literal["auto"] | None = None
    score_threshold: float | None = None


class Reasoning(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    effort: Literal["low", "medium", "high"] | None = None


class ReasoningModel(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    effort: Literal["low", "medium", "high"] | None = None
    summary: str | None = None


class Response(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    object: Literal["response"] = "response"
    created_at: int
    status: Literal["completed", "failed", "in_progress", "incomplete"]
    error: ResponseError | None = None
    incomplete_details: IncompleteDetails | None = None
    instructions: str | None = None
    max_output_tokens: int | None = None
    model: str
    output: list[MessageOutputItem]
    parallel_tool_calls: StrictBool = True
    previous_response_id: str | None = None
    reasoning: ReasoningModel | None = None
    store: StrictBool = True
    temperature: float = 1
    text: Text | None = None
    tool_choice: Literal["auto", "none"] | ToolChoice
    tools: list[Tool]
    top_p: float = 1
    truncation: Literal["disabled", "auto"]
    usage: ResponseUsage
    user: str | None = None
    metadata: dict[str, Any]


class ResponseError(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    message: str
    type: str
    param: str | None = None
    code: str | None = None


class ResponseUsage(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    input_tokens: int
    input_tokens_details: InputTokensDetails
    output_tokens: int
    output_tokens_details: OutputTokensDetails
    total_tokens: int


class Text(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    format: Format | None = None


class TextContentPart(ContentPart):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Literal["output_text"] = "output_text"
    text: str
    annotations: list[Annotation]


class TextInputContentItem(InputContentItem):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Literal["input_text"] = "input_text"
    text: str


class Tool(Annotation):
    pass


class ToolChoice(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Literal["function"] = "function"
    function: Function


class UrlCitationAnnotation(Annotation):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Literal["url_citation"] = "url_citation"
    start_index: int
    end_index: int
    url: str
    title: str


class UserLocation(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Literal["approximate"] = "approximate"
    city: str | None = None
    country: str | None = None
    region: str | None = None
    timezone: str | None = None


class WebSearchCallOutputItem(OutputItem):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Literal["web_search_call"] = "web_search_call"
    id: str
    status: Literal["completed", "in_progress"]


class WebSearchTool(Tool):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Literal["web_search_preview"] = "web_search_preview"
    domains: list[str] | None = None
    search_context_size: Literal["small", "medium", "large"] | None = None
    user_location: UserLocation | None = None


class FileSearchCallOutputItem(OutputItem):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Literal["file_search_call"] = "file_search_call"
    id: str
    status: Literal["completed", "in_progress"]
    queries: list[str]
    results: Any | None = None


class FileSearchTool(Tool):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Literal["file_search"] = "file_search"
    filters: Any | None = None
    max_num_results: int | None = None
    ranking_options: RankingOptions | None = None
    vector_store_ids: list[str]


class FunctionCallOutputItem(OutputItem):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Literal["function_call"] = "function_call"
    id: str
    call_id: str
    name: str
    arguments: str
    status: Literal["completed", "in_progress"]


class FunctionTool(Tool):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Literal["function"] = "function"
    name: str
    description: str | None = None
    parameters: dict[str, Any]
    strict: StrictBool | None = None


class ImageInputContentItem(InputContentItem):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Literal["input_image"] = "input_image"
    image_url: str


class MessageOutputItem(OutputItem):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Literal["message"] = "message"
    id: str
    status: Literal["completed", "in_progress"]
    role: Literal["assistant"] = "assistant"
    content: list[TextContentPart]
