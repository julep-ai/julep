import { compilerAssert, getDoc, getProperty, getService, getSummary, typespecTypeToJson, } from "@typespec/compiler";
import { setStatusCode } from "@typespec/http";
import { createDiagnostic, createStateSymbol, reportDiagnostic } from "./lib.js";
const operationIdsKey = createStateSymbol("operationIds");
/**
 * Set a specific operation ID.
 * @param context Decorator Context
 * @param entity Decorator target
 * @param opId Operation ID.
 */
export const $operationId = (context, entity, opId) => {
    context.program.stateMap(operationIdsKey).set(entity, opId);
};
/**
 * Returns operationId set via the `@operationId` decorator or `undefined`
 */
export function getOperationId(program, entity) {
    return program.stateMap(operationIdsKey).get(entity);
}
const openApiExtensionKey = createStateSymbol("openApiExtension");
/** {@inheritdoc ExtensionDecorator} */
export const $extension = (context, entity, extensionName, value) => {
    if (!isOpenAPIExtensionKey(extensionName)) {
        reportDiagnostic(context.program, {
            code: "invalid-extension-key",
            format: { value: extensionName },
            target: entity,
        });
    }
    const [data, diagnostics] = typespecTypeToJson(value, entity);
    if (diagnostics.length > 0) {
        context.program.reportDiagnostics(diagnostics);
    }
    setExtension(context.program, entity, extensionName, data);
};
/**
 * Set the OpenAPI info node on for the given service namespace.
 * @param program Program
 * @param entity Service namespace
 * @param data OpenAPI Info object
 */
export function setInfo(program, entity, data) {
    program.stateMap(infoKey).set(entity, data);
}
/**
 *  Set OpenAPI extension on the given type. Equivalent of using `@extension` decorator
 * @param program Program
 * @param entity Type to annotate
 * @param extensionName Extension key
 * @param data Extension value
 */
export function setExtension(program, entity, extensionName, data) {
    const openApiExtensions = program.stateMap(openApiExtensionKey);
    const typeExtensions = openApiExtensions.get(entity) ?? new Map();
    typeExtensions.set(extensionName, data);
    openApiExtensions.set(entity, typeExtensions);
}
/**
 * Get extensions set for the given type.
 * @param program Program
 * @param entity Type
 */
export function getExtensions(program, entity) {
    return program.stateMap(openApiExtensionKey).get(entity) ?? new Map();
}
function isOpenAPIExtensionKey(key) {
    return key.startsWith("x-");
}
/**
 * The @defaultResponse decorator can be applied to a model. When that model is used
 * as the return type of an operation, this return type will be the default response.
 *
 */
const defaultResponseKey = createStateSymbol("defaultResponse");
/** {@inheritdoc DefaultResponseDecorator} */
export const $defaultResponse = (context, entity) => {
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    setStatusCode(context.program, entity, ["*"]);
    context.program.stateSet(defaultResponseKey).add(entity);
};
/**
 * Check if the given model has been mark as a default response.
 * @param program TypeSpec Program
 * @param entity Model to check.
 * @returns boolean.
 */
export function isDefaultResponse(program, entity) {
    return program.stateSet(defaultResponseKey).has(entity);
}
const externalDocsKey = createStateSymbol("externalDocs");
/**
 * Allows referencing an external resource for extended documentation.
 * @param url The URL for the target documentation. Value MUST be in the format of a URL.
 * @param description A short description of the target documentation.
 */
export const $externalDocs = (context, target, url, description) => {
    const doc = { url };
    if (description) {
        doc.description = description;
    }
    context.program.stateMap(externalDocsKey).set(target, doc);
};
/**
 * Return external doc info set via the `@externalDocs` decorator.
 * @param program Program
 * @param entity Type
 */
export function getExternalDocs(program, entity) {
    return program.stateMap(externalDocsKey).get(entity);
}
const infoKey = createStateSymbol("info");
/** {@inheritdoc InfoDecorator} */
export const $info = (context, entity, model) => {
    const [data, diagnostics] = typespecTypeToJson(model, context.getArgumentTarget(0));
    context.program.reportDiagnostics(diagnostics);
    if (data === undefined) {
        return;
    }
    validateAdditionalInfoModel(context, model);
    if (data.termsOfService) {
        if (!validateIsUri(context, data.termsOfService, "TermsOfService")) {
            return;
        }
    }
    setInfo(context.program, entity, data);
};
/**
 * Get the info entry for the given service namespace.
 * @param program Program
 * @param entity Service namespace
 */
export function getInfo(program, entity) {
    return program.stateMap(infoKey).get(entity);
}
/** Resolve the info entry by merging data specified with `@service`, `@summary` and `@info`. */
export function resolveInfo(program, entity) {
    const info = getInfo(program, entity);
    const service = getService(program, entity);
    return omitUndefined({
        ...info,
        title: info?.title ?? service?.title,
        // eslint-disable-next-line @typescript-eslint/no-deprecated
        version: info?.version ?? service?.version,
        summary: info?.summary ?? getSummary(program, entity),
        description: info?.description ?? getDoc(program, entity),
    });
}
function omitUndefined(data) {
    return Object.fromEntries(Object.entries(data).filter(([k, v]) => v !== undefined));
}
function validateIsUri(context, url, propertyName) {
    try {
        new URL(url);
        return true;
    }
    catch {
        reportDiagnostic(context.program, {
            code: "not-url",
            target: context.getArgumentTarget(0),
            format: { property: propertyName, value: url },
        });
        return false;
    }
}
function validateAdditionalInfoModel(context, typespecType) {
    const propertyModel = context.program.resolveTypeReference("TypeSpec.OpenAPI.AdditionalInfo")[0];
    if (typeof typespecType === "object" && propertyModel) {
        const diagnostics = checkNoAdditionalProperties(typespecType, context.getArgumentTarget(0), propertyModel);
        context.program.reportDiagnostics(diagnostics);
    }
}
function checkNoAdditionalProperties(typespecType, target, source) {
    const diagnostics = [];
    compilerAssert(typespecType.kind === "Model", "Expected type to be a Model.");
    for (const [name, type] of typespecType.properties.entries()) {
        const sourceProperty = getProperty(source, name);
        if (sourceProperty) {
            if (sourceProperty.type.kind === "Model") {
                const nestedDiagnostics = checkNoAdditionalProperties(type.type, target, sourceProperty.type);
                diagnostics.push(...nestedDiagnostics);
            }
        }
        else if (!isOpenAPIExtensionKey(name)) {
            diagnostics.push(createDiagnostic({
                code: "invalid-extension-key",
                format: { value: name },
                target,
            }));
        }
    }
    return diagnostics;
}
//# sourceMappingURL=decorators.js.map