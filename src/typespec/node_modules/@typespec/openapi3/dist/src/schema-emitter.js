import { compilerAssert, explainStringTemplateNotSerializable, getDeprecated, getDiscriminatedUnion, getDiscriminator, getDoc, getEncode, getExamples, getFormat, getKnownValues, getMaxItems, getMaxLength, getMaxValue, getMaxValueExclusive, getMinItems, getMinLength, getMinValue, getMinValueExclusive, getNamespaceFullName, getPattern, getSummary, getTypeName, ignoreDiagnostics, isArrayModelType, isNeverType, isNullType, isSecret, isTemplateDeclaration, resolveEncodedName, serializeValueAsJson, } from "@typespec/compiler";
import { ArrayBuilder, ObjectBuilder, Placeholder, TypeEmitter, } from "@typespec/compiler/emitter-framework";
import { Visibility, getVisibilitySuffix } from "@typespec/http";
import { checkDuplicateTypeName, getExtensions, getExternalDocs, getOpenAPITypeName, isReadonlyProperty, shouldInline, } from "@typespec/openapi";
import { getOneOf, getRef } from "./decorators.js";
import { applyEncoding } from "./encoding.js";
import { reportDiagnostic } from "./lib.js";
import { getSchemaForStdScalars } from "./std-scalar-schemas.js";
/**
 * OpenAPI3 schema emitter. Deals with emitting content of `components/schemas` section.
 */
export class OpenAPI3SchemaEmitter extends TypeEmitter {
    #metadataInfo;
    #visibilityUsage;
    #options;
    constructor(emitter, metadataInfo, visibilityUsage, options) {
        super(emitter);
        this.#metadataInfo = metadataInfo;
        this.#visibilityUsage = visibilityUsage;
        this.#options = options;
    }
    modelDeclarationReferenceContext(model, name) {
        return this.reduceContext(model);
    }
    modelLiteralReferenceContext(model) {
        return this.reduceContext(model);
    }
    scalarDeclarationReferenceContext(scalar, name) {
        return this.reduceContext(scalar);
    }
    enumDeclarationReferenceContext(en, name) {
        return this.reduceContext(en);
    }
    unionDeclarationReferenceContext(union) {
        return this.reduceContext(union);
    }
    reduceContext(type) {
        const visibility = this.#getVisibilityContext();
        const patch = {};
        if (visibility !== Visibility.Read && !this.#metadataInfo.isTransformed(type, visibility)) {
            patch.visibility = Visibility.Read;
        }
        const contentType = this.#getContentType();
        if (contentType === "application/json") {
            patch.contentType = undefined;
        }
        return patch;
    }
    modelDeclaration(model, _) {
        const program = this.emitter.getProgram();
        const visibility = this.#getVisibilityContext();
        const schema = new ObjectBuilder({
            type: "object",
            required: this.#requiredModelProperties(model, visibility),
            properties: this.emitter.emitModelProperties(model),
        });
        if (model.indexer) {
            schema.set("additionalProperties", this.emitter.emitTypeReference(model.indexer.value));
        }
        const derivedModels = model.derivedModels.filter(includeDerivedModel);
        // getSchemaOrRef on all children to push them into components.schemas
        for (const child of derivedModels) {
            this.emitter.emitTypeReference(child);
        }
        const discriminator = getDiscriminator(program, model);
        if (discriminator) {
            const [union] = getDiscriminatedUnion(model, discriminator);
            const openApiDiscriminator = { ...discriminator };
            if (union.variants.size > 0) {
                openApiDiscriminator.mapping = this.#getDiscriminatorMapping(union);
            }
            schema.discriminator = openApiDiscriminator;
        }
        this.#applyExternalDocs(model, schema);
        if (model.baseModel) {
            schema.set("allOf", B.array([this.emitter.emitTypeReference(model.baseModel)]));
        }
        const baseName = getOpenAPITypeName(program, model, this.#typeNameOptions());
        const isMultipart = this.#getContentType().startsWith("multipart/");
        const name = isMultipart ? baseName + "MultiPart" : baseName;
        return this.#createDeclaration(model, name, this.#applyConstraints(model, schema));
    }
    #applyExternalDocs(typespecType, target) {
        const externalDocs = getExternalDocs(this.emitter.getProgram(), typespecType);
        if (externalDocs) {
            target.externalDocs = externalDocs;
        }
    }
    #typeNameOptions() {
        const serviceNamespaceName = this.emitter.getContext().serviceNamespaceName;
        return {
            // shorten type names by removing TypeSpec and service namespace
            namespaceFilter(ns) {
                const name = getNamespaceFullName(ns);
                return name !== serviceNamespaceName;
            },
        };
    }
    #getVisibilityContext() {
        return this.emitter.getContext().visibility ?? Visibility.Read;
    }
    #ignoreMetadataAnnotations() {
        return this.emitter.getContext().ignoreMetadataAnnotations;
    }
    #getContentType() {
        return this.emitter.getContext().contentType ?? "application/json";
    }
    modelLiteral(model) {
        const schema = new ObjectBuilder({
            type: "object",
            properties: this.emitter.emitModelProperties(model),
            required: this.#requiredModelProperties(model, this.#getVisibilityContext()),
        });
        if (model.indexer) {
            schema.set("additionalProperties", this.emitter.emitTypeReference(model.indexer.value));
        }
        return schema;
    }
    modelInstantiation(model, name) {
        name = name ?? getOpenAPITypeName(this.emitter.getProgram(), model, this.#typeNameOptions());
        if (!name) {
            return this.modelLiteral(model);
        }
        return this.modelDeclaration(model, name);
    }
    arrayDeclaration(array, name, elementType) {
        const schema = new ObjectBuilder({
            type: "array",
            items: this.emitter.emitTypeReference(elementType),
        });
        return this.#createDeclaration(array, name, this.#applyConstraints(array, schema));
    }
    arrayDeclarationReferenceContext(array, name, elementType) {
        return {
            visibility: this.#getVisibilityContext() | Visibility.Item,
        };
    }
    arrayLiteral(array, elementType) {
        return this.#inlineType(array, new ObjectBuilder({
            type: "array",
            items: this.emitter.emitTypeReference(elementType),
        }));
    }
    arrayLiteralReferenceContext(array, elementType) {
        return {
            visibility: this.#getVisibilityContext() | Visibility.Item,
        };
    }
    #requiredModelProperties(model, visibility) {
        const requiredProps = [];
        for (const prop of model.properties.values()) {
            if (isNeverType(prop.type)) {
                // If the property has a type of 'never', don't include it in the schema
                continue;
            }
            if (!this.#metadataInfo.isPayloadProperty(prop, visibility, this.#ignoreMetadataAnnotations())) {
                continue;
            }
            if (!this.#metadataInfo.isOptional(prop, visibility)) {
                const encodedName = resolveEncodedName(this.emitter.getProgram(), prop, this.#getContentType());
                requiredProps.push(encodedName);
            }
        }
        return requiredProps.length > 0 ? requiredProps : undefined;
    }
    modelProperties(model) {
        const program = this.emitter.getProgram();
        const props = new ObjectBuilder();
        const visibility = this.emitter.getContext().visibility;
        const contentType = this.#getContentType();
        for (const prop of model.properties.values()) {
            if (isNeverType(prop.type)) {
                // If the property has a type of 'never', don't include it in the schema
                continue;
            }
            if (!this.#metadataInfo.isPayloadProperty(prop, visibility, this.#ignoreMetadataAnnotations())) {
                continue;
            }
            const result = this.emitter.emitModelProperty(prop);
            const encodedName = resolveEncodedName(program, prop, contentType);
            props.set(encodedName, result);
        }
        const discriminator = getDiscriminator(program, model);
        if (discriminator && !(discriminator.propertyName in props)) {
            props.set(discriminator.propertyName, {
                type: "string",
                description: `Discriminator property for ${model.name}.`,
            });
        }
        if (Object.keys(props).length === 0) {
            return this.emitter.result.none();
        }
        return props;
    }
    modelPropertyLiteral(prop) {
        const program = this.emitter.getProgram();
        const isMultipart = this.#getContentType().startsWith("multipart/");
        if (isMultipart) {
            if (isBytesKeptRaw(program, prop.type) && getEncode(program, prop) === undefined) {
                return { type: "string", format: "binary" };
            }
            if (prop.type.kind === "Model" &&
                isArrayModelType(program, prop.type) &&
                isBytesKeptRaw(program, prop.type.indexer.value)) {
                return { type: "array", items: { type: "string", format: "binary" } };
            }
        }
        const refSchema = this.emitter.emitTypeReference(prop.type, {
            referenceContext: isMultipart &&
                (prop.type.kind !== "Union" ||
                    ![...prop.type.variants.values()].some((x) => isBytesKeptRaw(program, x.type)))
                ? { contentType: "application/json" }
                : {},
        });
        if (refSchema.kind !== "code") {
            reportDiagnostic(program, {
                code: "invalid-model-property",
                format: {
                    type: prop.type.kind,
                },
                target: prop,
            });
            return {};
        }
        const isRef = refSchema.value instanceof Placeholder || "$ref" in refSchema.value;
        const schema = this.#applyEncoding(prop, refSchema.value);
        // Apply decorators on the property to the type's schema
        const additionalProps = this.#applyConstraints(prop, {});
        if (prop.defaultValue) {
            additionalProps.default = getDefaultValue(program, prop.defaultValue, prop);
        }
        if (isReadonlyProperty(program, prop)) {
            additionalProps.readOnly = true;
        }
        // Attach any additional OpenAPI extensions
        this.#attachExtensions(program, prop, additionalProps);
        if (schema && isRef && !(prop.type.kind === "Model" && isArrayModelType(program, prop.type))) {
            if (Object.keys(additionalProps).length === 0) {
                return schema;
            }
            else {
                return {
                    allOf: [schema],
                    ...additionalProps,
                };
            }
        }
        else {
            if (getOneOf(program, prop) && schema.anyOf) {
                schema.oneOf = schema.anyOf;
                delete schema.anyOf;
            }
            const merged = new ObjectBuilder(schema);
            for (const [key, value] of Object.entries(additionalProps)) {
                merged.set(key, value);
            }
            return merged;
        }
    }
    booleanLiteral(boolean) {
        return { type: "boolean", enum: [boolean.value] };
    }
    stringLiteral(string) {
        return { type: "string", enum: [string.value] };
    }
    stringTemplate(string) {
        if (string.stringValue !== undefined) {
            return { type: "string", enum: [string.stringValue] };
        }
        const diagnostics = explainStringTemplateNotSerializable(string);
        this.emitter
            .getProgram()
            .reportDiagnostics(diagnostics.map((x) => ({ ...x, severity: "warning" })));
        return { type: "string" };
    }
    numericLiteral(number) {
        return { type: "number", enum: [number.value] };
    }
    enumDeclaration(en, name) {
        const baseName = getOpenAPITypeName(this.emitter.getProgram(), en, this.#typeNameOptions());
        return this.#createDeclaration(en, baseName, new ObjectBuilder(this.#enumSchema(en)));
    }
    #enumSchema(en) {
        const program = this.emitter.getProgram();
        if (en.members.size === 0) {
            reportDiagnostic(program, { code: "empty-enum", target: en });
            return {};
        }
        const enumTypes = new Set();
        const enumValues = new Set();
        for (const member of en.members.values()) {
            enumTypes.add(typeof member.value === "number" ? "number" : "string");
            enumValues.add(member.value ?? member.name);
        }
        if (enumTypes.size > 1) {
            reportDiagnostic(program, { code: "enum-unique-type", target: en });
        }
        const schema = {
            type: enumTypes.values().next().value,
            enum: [...enumValues],
        };
        return this.#applyConstraints(en, schema);
    }
    enumMember(member) {
        return this.enumMemberReference(member);
    }
    enumMemberReference(member) {
        // would like to dispatch to the same `literal` codepaths but enum members aren't literal types
        switch (typeof member.value) {
            case "undefined":
                return { type: "string", enum: [member.name] };
            case "string":
                return { type: "string", enum: [member.value] };
            case "number":
                return { type: "number", enum: [member.value] };
        }
    }
    unionDeclaration(union, name) {
        const schema = this.#unionSchema(union);
        const baseName = getOpenAPITypeName(this.emitter.getProgram(), union, this.#typeNameOptions());
        return this.#createDeclaration(union, baseName, schema);
    }
    #unionSchema(union) {
        const program = this.emitter.getProgram();
        if (union.variants.size === 0) {
            reportDiagnostic(program, { code: "empty-union", target: union });
            return new ObjectBuilder({});
        }
        const variants = Array.from(union.variants.values());
        const literalVariantEnumByType = {};
        const ofType = getOneOf(program, union) ? "oneOf" : "anyOf";
        const schemaMembers = [];
        let nullable = false;
        const discriminator = getDiscriminator(program, union);
        const isMultipart = this.#getContentType().startsWith("multipart/");
        for (const variant of variants) {
            if (isNullType(variant.type)) {
                nullable = true;
                continue;
            }
            if (isMultipart && isBytesKeptRaw(program, variant.type)) {
                schemaMembers.push({ schema: { type: "string", format: "binary" }, type: variant.type });
                continue;
            }
            if (isLiteralType(variant.type)) {
                if (!literalVariantEnumByType[variant.type.kind]) {
                    const enumValue = [variant.type.value];
                    literalVariantEnumByType[variant.type.kind] = enumValue;
                    schemaMembers.push({
                        schema: { type: literalType(variant.type), enum: enumValue },
                        type: null,
                    });
                }
                else {
                    literalVariantEnumByType[variant.type.kind].push(variant.type.value);
                }
            }
            else {
                const enumSchema = this.emitter.emitTypeReference(variant.type, {
                    referenceContext: isMultipart ? { contentType: "application/json" } : {},
                });
                compilerAssert(enumSchema.kind === "code", "Unexpected enum schema. Should be kind: code");
                schemaMembers.push({ schema: enumSchema.value, type: variant.type });
            }
        }
        const wrapWithObjectBuilder = (schemaMember, { mergeUnionWideConstraints }) => {
            // we can just return the single schema member after applying nullable
            const schema = schemaMember.schema;
            const type = schemaMember.type;
            const additionalProps = mergeUnionWideConstraints
                ? this.#applyConstraints(union, {})
                : {};
            if (mergeUnionWideConstraints && nullable) {
                additionalProps.nullable = true;
            }
            if (Object.keys(additionalProps).length === 0) {
                return new ObjectBuilder(schema);
            }
            else {
                if ((schema instanceof Placeholder || "$ref" in schema) &&
                    !(type && shouldInline(program, type))) {
                    if (type && type.kind === "Model") {
                        return new ObjectBuilder({
                            type: "object",
                            allOf: B.array([schema]),
                            ...additionalProps,
                        });
                    }
                    else {
                        return new ObjectBuilder({ oneOf: B.array([schema]), ...additionalProps });
                    }
                }
                else {
                    const merged = new ObjectBuilder(schema);
                    for (const [key, value] of Object.entries(additionalProps)) {
                        merged.set(key, value);
                    }
                    return merged;
                }
            }
        };
        if (schemaMembers.length === 0) {
            if (nullable) {
                // This union is equivalent to just `null` but OA3 has no way to specify
                // null as a value, so we throw an error.
                reportDiagnostic(program, { code: "union-null", target: union });
                return new ObjectBuilder({});
            }
            else {
                // completely empty union can maybe only happen with bugs?
                compilerAssert(false, "Attempting to emit an empty union");
            }
        }
        if (schemaMembers.length === 1) {
            return wrapWithObjectBuilder(schemaMembers[0], { mergeUnionWideConstraints: true });
        }
        const schema = {
            [ofType]: schemaMembers.map((m) => wrapWithObjectBuilder(m, { mergeUnionWideConstraints: false })),
        };
        if (nullable) {
            schema.nullable = true;
        }
        if (discriminator) {
            // the decorator validates that all the variants will be a model type
            // with the discriminator field present.
            schema.discriminator = { ...discriminator };
            // Diagnostic already reported in compiler for unions
            const discriminatedUnion = ignoreDiagnostics(getDiscriminatedUnion(union, discriminator));
            if (discriminatedUnion.variants.size > 0) {
                schema.discriminator.mapping = this.#getDiscriminatorMapping(discriminatedUnion);
            }
        }
        return this.#applyConstraints(union, schema);
    }
    #getDiscriminatorMapping(union) {
        const mapping = {};
        for (const [key, model] of union.variants.entries()) {
            const ref = this.emitter.emitTypeReference(model);
            compilerAssert(ref.kind === "code", "Unexpected ref schema. Should be kind: code");
            mapping[key] = ref.value.$ref;
        }
        return mapping;
    }
    unionLiteral(union) {
        return this.#unionSchema(union);
    }
    unionVariants(union) {
        const variants = new ArrayBuilder();
        for (const variant of union.variants.values()) {
            variants.push(this.emitter.emitType(variant));
        }
        return variants;
    }
    unionVariant(variant) {
        return this.emitter.emitTypeReference(variant.type);
    }
    modelPropertyReference(prop) {
        return this.modelPropertyLiteral(prop);
    }
    #attachExtensions(program, type, emitObject) {
        // Attach any OpenAPI extensions
        const extensions = getExtensions(program, type);
        if (extensions) {
            for (const key of extensions.keys()) {
                emitObject[key] = extensions.get(key);
            }
        }
    }
    reference(targetDeclaration, pathUp, pathDown, commonScope) {
        if (targetDeclaration.value instanceof Placeholder) {
            // I don't think this is possible, confirm.
            throw new Error("Can't form reference to declaration that hasn't been created yet");
        }
        // these will be undefined when creating a self-reference
        const currentSfScope = pathUp[pathUp.length - 1];
        const targetSfScope = pathDown[0];
        if (targetSfScope && currentSfScope && !targetSfScope.sourceFile.meta.shouldEmit) {
            currentSfScope.sourceFile.meta.bundledRefs.push(targetDeclaration);
        }
        return { $ref: `#/components/schemas/${targetDeclaration.name}` };
    }
    circularReference(target, scope, cycle) {
        if (!cycle.containsDeclaration) {
            reportDiagnostic(this.emitter.getProgram(), {
                code: "inline-cycle",
                format: {
                    type: cycle.toString(),
                },
                target: cycle.first.type,
            });
            return {};
        }
        return super.circularReference(target, scope, cycle);
    }
    scalarDeclaration(scalar, name) {
        const isStd = this.#isStdType(scalar);
        const schema = this.#getSchemaForScalar(scalar);
        const baseName = getOpenAPITypeName(this.emitter.getProgram(), scalar, this.#typeNameOptions());
        // Don't create a declaration for std types
        return isStd ? schema : this.#createDeclaration(scalar, baseName, new ObjectBuilder(schema));
    }
    scalarInstantiation(scalar, name) {
        return this.#getSchemaForScalar(scalar);
    }
    tupleLiteral(tuple) {
        return { type: "array", items: {} };
    }
    #getSchemaForScalar(scalar) {
        let result = {};
        const isStd = this.#isStdType(scalar);
        if (isStd) {
            result = this.#getSchemaForStdScalars(scalar);
        }
        else if (scalar.baseScalar) {
            result = this.#getSchemaForScalar(scalar.baseScalar);
        }
        const withDecorators = this.#applyEncoding(scalar, this.#applyConstraints(scalar, result));
        if (isStd) {
            // Standard types are going to be inlined in the spec and we don't want the description of the scalar to show up
            delete withDecorators.description;
        }
        return withDecorators;
    }
    #getSchemaForStdScalars(scalar) {
        return getSchemaForStdScalars(scalar, this.#options);
    }
    #applySchemaExamples(type, target) {
        const program = this.emitter.getProgram();
        const examples = getExamples(program, type);
        if (examples.length > 0) {
            target.set("example", serializeValueAsJson(program, examples[0].value, type));
        }
    }
    #applyConstraints(type, original) {
        const schema = new ObjectBuilder(original);
        const program = this.emitter.getProgram();
        const applyConstraint = (fn, key) => {
            const value = fn(program, type);
            if (value !== undefined) {
                schema[key] = value;
            }
        };
        this.#applySchemaExamples(type, schema);
        applyConstraint(getMinLength, "minLength");
        applyConstraint(getMaxLength, "maxLength");
        applyConstraint(getMinValue, "minimum");
        applyConstraint(getMaxValue, "maximum");
        applyConstraint(getPattern, "pattern");
        applyConstraint(getMinItems, "minItems");
        applyConstraint(getMaxItems, "maxItems");
        const minValueExclusive = getMinValueExclusive(program, type);
        if (minValueExclusive !== undefined) {
            schema.minimum = minValueExclusive;
            schema.exclusiveMinimum = true;
        }
        const maxValueExclusive = getMaxValueExclusive(program, type);
        if (maxValueExclusive !== undefined) {
            schema.maximum = maxValueExclusive;
            schema.exclusiveMaximum = true;
        }
        if (isSecret(program, type)) {
            schema.format = "password";
        }
        // the stdlib applies a format of "url" but json schema wants "uri",
        // so ignore this format if it's the built-in type.
        if (!this.#isStdType(type) || type.name !== "url") {
            applyConstraint(getFormat, "format");
        }
        applyConstraint(getDoc, "description");
        applyConstraint(getSummary, "title");
        applyConstraint((p, t) => (getDeprecated(p, t) !== undefined ? true : undefined), "deprecated");
        this.#attachExtensions(program, type, schema);
        const values = getKnownValues(program, type);
        if (values) {
            return new ObjectBuilder({
                oneOf: [schema, this.#enumSchema(values)],
            });
        }
        return new ObjectBuilder(schema);
    }
    #inlineType(type, schema) {
        if (this.#options.includeXTypeSpecName !== "never") {
            schema.set("x-typespec-name", getTypeName(type, this.#typeNameOptions()));
        }
        return schema;
    }
    #createDeclaration(type, name, schema) {
        const refUrl = getRef(this.emitter.getProgram(), type);
        if (refUrl) {
            return {
                $ref: refUrl,
            };
        }
        if (shouldInline(this.emitter.getProgram(), type)) {
            return this.#inlineType(type, schema);
        }
        const title = getSummary(this.emitter.getProgram(), type);
        if (title) {
            schema.set("title", title);
        }
        const usage = this.#visibilityUsage.getUsage(type);
        const shouldAddSuffix = usage !== undefined && usage.size > 1;
        const visibility = this.#getVisibilityContext();
        const fullName = name + (shouldAddSuffix ? getVisibilitySuffix(visibility, Visibility.Read) : "");
        const decl = this.emitter.result.declaration(fullName, schema);
        checkDuplicateTypeName(this.emitter.getProgram(), type, fullName, Object.fromEntries(decl.scope.declarations.map((x) => [x.name, true])));
        return decl;
    }
    #isStdType(type) {
        return this.emitter.getProgram().checker.isStdType(type);
    }
    #applyEncoding(typespecType, target) {
        return applyEncoding(this.emitter.getProgram(), typespecType, target, this.#options);
    }
    intrinsic(intrinsic, name) {
        switch (name) {
            case "unknown":
                return {};
            case "null":
                return { nullable: true };
        }
        reportDiagnostic(this.emitter.getProgram(), {
            code: "invalid-schema",
            format: { type: name },
            target: intrinsic,
        });
        return {};
    }
    programContext(program) {
        const sourceFile = this.emitter.createSourceFile("openapi");
        return { scope: sourceFile.globalScope };
    }
}
function isLiteralType(type) {
    return type.kind === "Boolean" || type.kind === "String" || type.kind === "Number";
}
function literalType(type) {
    switch (type.kind) {
        case "String":
            return "string";
        case "Number":
            return "number";
        case "Boolean":
            return "boolean";
    }
}
function includeDerivedModel(model) {
    return (!isTemplateDeclaration(model) &&
        (model.templateMapper?.args === undefined ||
            model.templateMapper.args?.length === 0 ||
            model.derivedModels.length > 0));
}
const B = {
    array: (items) => {
        const builder = new ArrayBuilder();
        for (const item of items) {
            builder.push(item);
        }
        return builder;
    },
    object: (obj) => {
        const builder = new ObjectBuilder();
        for (const [key, value] of Object.entries(obj)) {
            builder.set(key, value);
        }
        return builder;
    },
};
export function getDefaultValue(program, defaultType, modelProperty) {
    return serializeValueAsJson(program, defaultType, modelProperty);
}
export function isBytesKeptRaw(program, type) {
    return type.kind === "Scalar" && type.name === "bytes" && getEncode(program, type) === undefined;
}
//# sourceMappingURL=schema-emitter.js.map