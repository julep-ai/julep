import { printIdentifier } from "@typespec/compiler";
import { getDecoratorsForSchema } from "../utils/decorators.js";
import { getScopeAndName } from "../utils/get-scope-and-name.js";
/**
 * Transforms #/components/schemas into TypeSpec models.
 * Populates the provided `models` array in-place.
 * @param models
 * @param schemas
 * @returns
 */
export function transformComponentSchemas(context, models) {
    const schemas = context.openApi3Doc.components?.schemas;
    if (!schemas)
        return;
    for (const name of Object.keys(schemas)) {
        const schema = schemas[name];
        transformComponentSchema(models, name, schema);
    }
    return;
    function transformComponentSchema(types, name, schema) {
        const kind = getTypeSpecKind(schema);
        switch (kind) {
            case "alias":
                return populateAlias(types, name, schema);
            case "enum":
                return populateEnum(types, name, schema);
            case "model":
                return populateModel(types, name, schema);
            case "union":
                return populateUnion(types, name, schema);
            case "scalar":
                return populateScalar(types, name, schema);
        }
    }
    function populateAlias(types, rawName, schema) {
        if (!("$ref" in schema)) {
            return;
        }
        const { name, scope } = getScopeAndName(rawName);
        types.push({
            kind: "alias",
            name,
            scope,
            doc: schema.description,
            ref: context.getRefName(schema.$ref, scope),
        });
    }
    function populateEnum(types, name, schema) {
        const tsEnum = {
            kind: "enum",
            ...getScopeAndName(name),
            decorators: getDecoratorsForSchema(schema),
            doc: schema.description,
            schema,
        };
        types.push(tsEnum);
    }
    function populateModel(types, rawName, schema) {
        const { name, scope } = getScopeAndName(rawName);
        const allOfDetails = getAllOfDetails(schema, scope);
        const isParent = getModelIs(schema, scope);
        types.push({
            kind: "model",
            name,
            scope,
            decorators: [...getDecoratorsForSchema(schema)],
            doc: schema.description,
            properties: [...getModelPropertiesFromObjectSchema(schema), ...allOfDetails.properties],
            additionalProperties: typeof schema.additionalProperties === "object" ? schema.additionalProperties : undefined,
            extends: allOfDetails.extends,
            is: isParent,
            type: schema.type,
            spread: allOfDetails.spread,
        });
    }
    function populateUnion(types, name, schema) {
        const union = {
            kind: "union",
            ...getScopeAndName(name),
            decorators: getDecoratorsForSchema(schema),
            doc: schema.description,
            schema,
        };
        types.push(union);
    }
    function populateScalar(types, name, schema) {
        types.push({
            kind: "scalar",
            ...getScopeAndName(name),
            decorators: getDecoratorsForSchema(schema),
            doc: schema.description,
            schema,
        });
    }
    function getAllOfDetails(schema, callingScope) {
        const details = {
            spread: [],
            properties: [],
        };
        if (!schema.allOf) {
            return details;
        }
        let foundParentWithDiscriminator = false;
        for (const member of schema.allOf) {
            // inline-schemas treated as normal objects with properties
            if (!("$ref" in member)) {
                details.properties.push(...getModelPropertiesFromObjectSchema(member));
                continue;
            }
            const refSchema = context.getSchemaByRef(member.$ref);
            // Inheritance only supported if parent has a discriminator defined, otherwise prefer
            // composition via spreading.
            if (!refSchema?.discriminator) {
                details.spread.push(context.getRefName(member.$ref, callingScope));
                continue;
            }
            if (!foundParentWithDiscriminator) {
                details.extends = context.getRefName(member.$ref, callingScope);
                foundParentWithDiscriminator = true;
                continue;
            }
            // can only extend once, so if we have multiple potential parents, spread them all
            // user will need to resolve TypeSpec errors (e.g. duplicate fields) manually
            if (details.extends) {
                details.spread.push(details.extends);
                details.extends = undefined;
            }
            details.spread.push(context.getRefName(member.$ref, callingScope));
        }
        return details;
    }
    function getModelIs(schema, callingScope) {
        if (schema.type !== "array") {
            return;
        }
        return context.generateTypeFromRefableSchema(schema, callingScope);
    }
}
function getModelPropertiesFromObjectSchema({ properties, required = [], }) {
    if (!properties)
        return [];
    const modelProperties = [];
    for (const name of Object.keys(properties)) {
        const property = properties[name];
        modelProperties.push({
            name: printIdentifier(name),
            doc: property.description,
            schema: property,
            isOptional: !required.includes(name),
            decorators: [...getDecoratorsForSchema(property)],
        });
    }
    return modelProperties;
}
function getTypeSpecKind(schema) {
    if ("$ref" in schema) {
        return "alias";
    }
    if (schema.enum && schema.type === "string" && !schema.nullable) {
        return "enum";
    }
    else if (schema.anyOf || schema.oneOf || schema.enum || schema.nullable) {
        return "union";
    }
    else if (schema.type === "object" || schema.type === "array" || schema.allOf) {
        return "model";
    }
    return "scalar";
}
//# sourceMappingURL=transform-component-schemas.js.map