import { compilerAssert, createDiagnosticCollector, emitFile, getAllTags, getAnyExtensionFromPath, getDoc, getFormat, getKnownValues, getMaxItems, getMaxLength, getMaxValue, getMaxValueExclusive, getMinItems, getMinLength, getMinValue, getMinValueExclusive, getNamespaceFullName, getPattern, getService, getSummary, ignoreDiagnostics, interpolatePath, isDeprecated, isGlobalNamespace, isNeverType, isSecret, isVoidType, listServices, navigateTypesInNamespace, projectProgram, resolvePath, } from "@typespec/compiler";
import { createAssetEmitter } from "@typespec/compiler/emitter-framework";
import { createMetadataInfo, getHttpService, getServers, getStatusCodeDescription, isContentTypeHeader, isOrExtendsHttpFile, isOverloadSameEndpoint, reportIfNoRoutes, resolveAuthentication, resolveRequestVisibility, Visibility, } from "@typespec/http";
import { getExtensions, getExternalDocs, getOpenAPITypeName, getParameterKey, isReadonlyProperty, resolveInfo, resolveOperationId, shouldInline, } from "@typespec/openapi";
import { buildVersionProjections } from "@typespec/versioning";
import { stringify } from "yaml";
import { getRef } from "./decorators.js";
import { applyEncoding } from "./encoding.js";
import { getExampleOrExamples, resolveOperationExamples } from "./examples.js";
import { createDiagnostic } from "./lib.js";
import { getDefaultValue, isBytesKeptRaw, OpenAPI3SchemaEmitter } from "./schema-emitter.js";
import { getOpenAPI3StatusCodes } from "./status-codes.js";
import { deepEquals, isSharedHttpOperation } from "./util.js";
import { resolveVisibilityUsage } from "./visibility-usage.js";
const defaultFileType = "yaml";
const defaultOptions = {
    "new-line": "lf",
    "omit-unreachable-types": false,
    "include-x-typespec-name": "never",
    "safeint-strategy": "int64",
};
export async function $onEmit(context) {
    const options = resolveOptions(context);
    const emitter = createOAPIEmitter(context, options);
    await emitter.emitOpenAPI();
}
/**
 * Get the OpenAPI 3 document records from the given program. The documents are
 * returned as a JS object.
 *
 * @param program The program to emit to OpenAPI 3
 * @param options OpenAPI 3 emit options
 * @returns An array of OpenAPI 3 document records.
 */
export async function getOpenAPI3(program, options = {}) {
    const context = {
        program,
        // this value doesn't matter for getting the OpenAPI3 objects
        emitterOutputDir: "tsp-output",
        options: options,
        getAssetEmitter(TypeEmitterClass) {
            return createAssetEmitter(program, TypeEmitterClass, this);
        },
    };
    const resolvedOptions = resolveOptions(context);
    const emitter = createOAPIEmitter(context, resolvedOptions);
    return emitter.getOpenAPI();
}
function findFileTypeFromFilename(filename) {
    if (filename === undefined) {
        return defaultFileType;
    }
    switch (getAnyExtensionFromPath(filename)) {
        case ".yaml":
        case ".yml":
            return "yaml";
        case ".json":
            return "json";
        default:
            return defaultFileType;
    }
}
export function resolveOptions(context) {
    const resolvedOptions = { ...defaultOptions, ...context.options };
    const fileType = resolvedOptions["file-type"] ?? findFileTypeFromFilename(resolvedOptions["output-file"]);
    const outputFile = resolvedOptions["output-file"] ?? `openapi.{service-name}.{version}.${fileType}`;
    return {
        fileType,
        newLine: resolvedOptions["new-line"],
        omitUnreachableTypes: resolvedOptions["omit-unreachable-types"],
        includeXTypeSpecName: resolvedOptions["include-x-typespec-name"],
        safeintStrategy: resolvedOptions["safeint-strategy"],
        outputFile: resolvePath(context.emitterOutputDir, outputFile),
    };
}
function createOAPIEmitter(context, options) {
    let program = context.program;
    let schemaEmitter;
    let root;
    let diagnostics;
    let currentService;
    let serviceAuth;
    // Get the service namespace string for use in name shortening
    let serviceNamespaceName;
    let currentPath;
    let metadataInfo;
    let visibilityUsage;
    // Map model properties that represent shared parameters to their parameter
    // definition that will go in #/components/parameters. Inlined parameters do not go in
    // this map.
    let params;
    // Keep track of models that have had properties spread into parameters. We won't
    // consider these unreferenced when emitting unreferenced types.
    let paramModels;
    // De-dupe the per-endpoint tags that will be added into the #/tags
    let tags;
    const typeNameOptions = {
        // shorten type names by removing TypeSpec and service namespace
        namespaceFilter(ns) {
            const name = getNamespaceFullName(ns);
            return name !== serviceNamespaceName;
        },
    };
    return { emitOpenAPI, getOpenAPI };
    async function emitOpenAPI() {
        const services = await getOpenAPI();
        // first, emit diagnostics
        for (const serviceRecord of services) {
            if (serviceRecord.versioned) {
                for (const documentRecord of serviceRecord.versions) {
                    program.reportDiagnostics(documentRecord.diagnostics);
                }
            }
            else {
                program.reportDiagnostics(serviceRecord.diagnostics);
            }
        }
        if (program.compilerOptions.noEmit || program.hasError()) {
            return;
        }
        const multipleService = services.length > 1;
        for (const serviceRecord of services) {
            if (serviceRecord.versioned) {
                for (const documentRecord of serviceRecord.versions) {
                    await emitFile(program, {
                        path: resolveOutputFile(serviceRecord.service, multipleService, documentRecord.version),
                        content: serializeDocument(documentRecord.document, options.fileType),
                        newLine: options.newLine,
                    });
                }
            }
            else {
                await emitFile(program, {
                    path: resolveOutputFile(serviceRecord.service, multipleService),
                    content: serializeDocument(serviceRecord.document, options.fileType),
                    newLine: options.newLine,
                });
            }
        }
    }
    function initializeEmitter(service, allHttpAuthentications, defaultAuth, version) {
        diagnostics = createDiagnosticCollector();
        currentService = service;
        metadataInfo = createMetadataInfo(program, {
            canonicalVisibility: Visibility.Read,
            canShareProperty: (p) => isReadonlyProperty(program, p),
        });
        visibilityUsage = resolveVisibilityUsage(program, metadataInfo, service.type, options.omitUnreachableTypes);
        schemaEmitter = createAssetEmitter(program, class extends OpenAPI3SchemaEmitter {
            constructor(emitter) {
                super(emitter, metadataInfo, visibilityUsage, options);
            }
        }, context);
        const securitySchemes = getOpenAPISecuritySchemes(allHttpAuthentications);
        const security = getOpenAPISecurity(defaultAuth);
        const info = resolveInfo(program, service.type);
        root = {
            openapi: "3.0.0",
            info: {
                title: "(title)",
                ...info,
                version: version ?? info?.version ?? "0.0.0",
            },
            externalDocs: getExternalDocs(program, service.type),
            tags: [],
            paths: {},
            security: security.length > 0 ? security : undefined,
            components: {
                parameters: {},
                requestBodies: {},
                responses: {},
                schemas: {},
                examples: {},
                securitySchemes: securitySchemes,
            },
        };
        const servers = getServers(program, service.type);
        if (servers) {
            root.servers = resolveServers(servers);
        }
        attachExtensions(program, service.type, root);
        serviceNamespaceName = getNamespaceFullName(service.type);
        currentPath = root.paths;
        params = new Map();
        paramModels = new Set();
        tags = new Set();
    }
    function isValidServerVariableType(program, type) {
        switch (type.kind) {
            case "String":
            case "Union":
            case "Scalar":
                return ignoreDiagnostics(program.checker.isTypeAssignableTo(type.projectionBase ?? type, program.checker.getStdType("string"), type));
            case "Enum":
                for (const member of type.members.values()) {
                    if (member.value && typeof member.value !== "string") {
                        return false;
                    }
                }
                return true;
            default:
                return false;
        }
    }
    function validateValidServerVariable(program, prop) {
        const isValid = isValidServerVariableType(program, prop.type);
        if (!isValid) {
            diagnostics.add(createDiagnostic({
                code: "invalid-server-variable",
                format: { propName: prop.name },
                target: prop,
            }));
        }
        return isValid;
    }
    function resolveServers(servers) {
        return servers.map((server) => {
            const variables = {};
            for (const [name, prop] of server.parameters) {
                if (!validateValidServerVariable(program, prop)) {
                    continue;
                }
                const variable = {
                    default: prop.defaultValue ? getDefaultValue(program, prop.defaultValue, prop) : "",
                    description: getDoc(program, prop),
                };
                if (prop.type.kind === "Enum") {
                    variable.enum = getSchemaValue(prop.type, Visibility.Read, "application/json")
                        .enum;
                }
                else if (prop.type.kind === "Union") {
                    variable.enum = getSchemaValue(prop.type, Visibility.Read, "application/json")
                        .enum;
                }
                else if (prop.type.kind === "String") {
                    variable.enum = [prop.type.value];
                }
                attachExtensions(program, prop, variable);
                variables[name] = variable;
            }
            return {
                url: server.url,
                description: server.description,
                variables,
            };
        });
    }
    async function getOpenAPI() {
        const serviceRecords = [];
        const services = listServices(program);
        if (services.length === 0) {
            services.push({ type: program.getGlobalNamespaceType() });
        }
        for (const service of services) {
            const versions = buildVersionProjections(program, service.type);
            if (versions.length === 1 && versions[0].version === undefined) {
                // non-versioned spec
                const document = await getProjectedOpenAPIDocument(service, versions[0]);
                if (document === undefined) {
                    // an error occurred producing this document, so don't return it
                    return serviceRecords;
                }
                serviceRecords.push({
                    service,
                    versioned: false,
                    document: document[0],
                    diagnostics: document[1],
                });
            }
            else {
                // versioned spec
                const serviceRecord = {
                    service,
                    versioned: true,
                    versions: [],
                };
                serviceRecords.push(serviceRecord);
                for (const record of versions) {
                    const document = await getProjectedOpenAPIDocument(service, record);
                    if (document === undefined) {
                        // an error occurred producing this document
                        continue;
                    }
                    serviceRecord.versions.push({
                        service,
                        version: record.version,
                        document: document[0],
                        diagnostics: document[1],
                    });
                }
            }
        }
        return serviceRecords;
        async function getProjectedOpenAPIDocument(service, record) {
            const commonProjections = [
                {
                    projectionName: "target",
                    arguments: ["json"],
                },
            ];
            const originalProgram = program;
            const projectedProgram = (program = projectProgram(originalProgram, [
                ...commonProjections,
                ...record.projections,
            ]));
            const projectedServiceNs = projectedProgram.projector.projectedTypes.get(service.type);
            const document = await getOpenApiFromVersion(projectedServiceNs === projectedProgram.getGlobalNamespaceType()
                ? { type: projectedProgram.getGlobalNamespaceType() }
                : getService(program, projectedServiceNs), record.version);
            return document;
        }
    }
    function resolveOutputFile(service, multipleService, version) {
        return interpolatePath(options.outputFile, {
            "service-name": multipleService ? getNamespaceFullName(service.type) : undefined,
            version,
        });
    }
    /**
     * Validates that common responses are consistent and returns the minimal set that describes the differences.
     */
    function deduplicateCommonResponses(statusCodeResponses) {
        const ref = statusCodeResponses[0];
        const sameTypeKind = statusCodeResponses.every((r) => r.type.kind === ref.type.kind);
        const sameTypeValue = statusCodeResponses.every((r) => r.type === ref.type);
        if (sameTypeKind && sameTypeValue) {
            // response is consistent and in all shared operations. Only need one copy.
            return [ref];
        }
        else {
            return statusCodeResponses;
        }
    }
    /**
     * Validates that common parameters are consistent and returns the minimal set that describes the differences.
     */
    function resolveSharedRouteParameters(ops) {
        const finalParams = [];
        const parameters = new Map();
        for (const op of ops) {
            for (const parameter of op.parameters.parameters) {
                const existing = parameters.get(parameter.name);
                if (existing) {
                    existing.push(parameter);
                }
                else {
                    parameters.set(parameter.name, [parameter]);
                }
            }
        }
        if (parameters.size === 0) {
            return [];
        }
        for (const sharedParams of parameters.values()) {
            const reference = sharedParams[0];
            const inAllOps = ops.length === sharedParams.length;
            const sameLocations = sharedParams.every((p) => p.type === reference.type);
            const sameOptionality = sharedParams.every((p) => p.param.optional === reference.param.optional);
            const sameTypeKind = sharedParams.every((p) => p.param.type.kind === reference.param.type.kind);
            const sameTypeValue = sharedParams.every((p) => p.param.type === reference.param.type);
            if (inAllOps && sameLocations && sameOptionality && sameTypeKind && sameTypeValue) {
                // param is consistent and in all shared operations. Only need one copy.
                finalParams.push(reference);
            }
            else if (!inAllOps && sameLocations && sameOptionality && sameTypeKind && sameTypeValue) {
                // param is consistent when used, but does not appear in all shared operations. Only need one copy, but it must be optional.
                reference.param.optional = true;
                finalParams.push(reference);
            }
            else if (inAllOps && !(sameLocations && sameOptionality && sameTypeKind)) {
                // param is in all shared operations, but is not consistent. Need multiple copies, which must be optional.
                // exception allowed when the params only differ by their value (e.g. string enum values)
                sharedParams.forEach((p) => {
                    p.param.optional = true;
                });
                finalParams.push(...sharedParams);
            }
            else {
                finalParams.push(...sharedParams);
            }
        }
        return finalParams;
    }
    function buildSharedOperation(operations) {
        return {
            kind: "shared",
            operations: operations,
        };
    }
    /**
     * Groups HttpOperations together if they share the same route.
     */
    function resolveOperations(operations) {
        const result = [];
        const pathMap = new Map();
        operations.forEach((op) => {
            // we don't emit overloads anyhow so emit them from grouping
            if (op.overloading !== undefined && isOverloadSameEndpoint(op)) {
                return;
            }
            const opKey = `${op.verb}|${op.path}`;
            pathMap.has(opKey) ? pathMap.get(opKey).push(op) : pathMap.set(opKey, [op]);
        });
        // now push either the singular HttpOperations or the constructed SharedHttpOperations
        for (const [_, ops] of pathMap) {
            if (ops.length === 1) {
                result.push(ops[0]);
            }
            else {
                result.push(buildSharedOperation(ops));
            }
        }
        return result;
    }
    async function getOpenApiFromVersion(service, version) {
        try {
            const httpService = ignoreDiagnostics(getHttpService(program, service.type));
            const auth = (serviceAuth = resolveAuthentication(httpService));
            initializeEmitter(service, auth.schemes, auth.defaultAuth, version);
            reportIfNoRoutes(program, httpService.operations);
            for (const op of resolveOperations(httpService.operations)) {
                const result = getOperationOrSharedOperation(op);
                if (result) {
                    const { operation, path, verb } = result;
                    currentPath[path] ??= {};
                    currentPath[path][verb] = operation;
                }
            }
            emitParameters();
            emitSchemas(service.type);
            emitTags();
            // Clean up empty entries
            if (root.components) {
                for (const elem of Object.keys(root.components)) {
                    if (Object.keys(root.components[elem]).length === 0) {
                        delete root.components[elem];
                    }
                }
            }
            return [root, diagnostics.diagnostics];
        }
        catch (err) {
            if (err instanceof ErrorTypeFoundError) {
                // Return early, there must be a parse error if an ErrorType was
                // inserted into the TypeSpec output
                return;
            }
            else {
                throw err;
            }
        }
    }
    function joinOps(operations, func, joinChar) {
        const values = operations
            .map((op) => func(program, op.operation))
            .filter((op) => op !== undefined);
        if (values.length) {
            return values.join(joinChar);
        }
        else {
            return undefined;
        }
    }
    function computeSharedOperationId(shared) {
        return shared.operations.map((op) => resolveOperationId(program, op.operation)).join("_");
    }
    function getOperationOrSharedOperation(operation) {
        if (isSharedHttpOperation(operation)) {
            return getSharedOperation(operation);
        }
        else {
            return getOperation(operation);
        }
    }
    function getSharedOperation(shared) {
        const operations = shared.operations;
        const verb = operations[0].verb;
        const path = operations[0].path;
        const examples = resolveOperationExamples(program, shared);
        const oai3Operation = {
            operationId: computeSharedOperationId(shared),
            parameters: [],
            description: joinOps(operations, getDoc, " "),
            summary: joinOps(operations, getSummary, " "),
            responses: getSharedResponses(shared, examples),
        };
        for (const op of operations) {
            applyExternalDocs(op.operation, oai3Operation);
            attachExtensions(program, op.operation, oai3Operation);
            if (isDeprecated(program, op.operation)) {
                oai3Operation.deprecated = true;
            }
        }
        for (const op of operations) {
            const opTags = getAllTags(program, op.operation);
            if (opTags) {
                const currentTags = oai3Operation.tags;
                if (currentTags) {
                    // combine tags but eliminate duplicates
                    oai3Operation.tags = [...new Set([...currentTags, ...opTags])];
                }
                else {
                    oai3Operation.tags = opTags;
                }
                for (const tag of opTags) {
                    // Add to root tags if not already there
                    tags.add(tag);
                }
            }
        }
        // Error out if shared routes do not have consistent `@parameterVisibility`. We can
        // lift this restriction in the future if a use case develops.
        const visibilities = operations.map((op) => resolveRequestVisibility(program, op.operation, verb));
        if (visibilities.some((v) => v !== visibilities[0])) {
            diagnostics.add(createDiagnostic({
                code: "inconsistent-shared-route-request-visibility",
                target: operations[0].operation,
            }));
        }
        const visibility = visibilities[0];
        oai3Operation.parameters = getEndpointParameters(resolveSharedRouteParameters(operations), visibility);
        const bodies = [
            ...new Set(operations.map((op) => op.parameters.body).filter((x) => x !== undefined)),
        ];
        if (bodies) {
            oai3Operation.requestBody = getRequestBody(bodies, visibility, examples);
        }
        const authReference = serviceAuth.operationsAuth.get(shared.operations[0].operation);
        if (authReference) {
            oai3Operation.security = getEndpointSecurity(authReference);
        }
        return { operation: oai3Operation, verb, path };
    }
    function getOperation(operation) {
        const { path: fullPath, operation: op, verb, parameters } = operation;
        // If path contains a query string, issue msg and don't emit this endpoint
        if (fullPath.indexOf("?") > 0) {
            diagnostics.add(createDiagnostic({ code: "path-query", target: op }));
            return undefined;
        }
        const visibility = resolveRequestVisibility(program, operation.operation, verb);
        const examples = resolveOperationExamples(program, operation);
        const oai3Operation = {
            operationId: resolveOperationId(program, operation.operation),
            summary: getSummary(program, operation.operation),
            description: getDoc(program, operation.operation),
            parameters: getEndpointParameters(parameters.parameters, visibility),
            responses: getResponses(operation, operation.responses, examples),
        };
        const currentTags = getAllTags(program, op);
        if (currentTags) {
            oai3Operation.tags = currentTags;
            for (const tag of currentTags) {
                // Add to root tags if not already there
                tags.add(tag);
            }
        }
        applyExternalDocs(op, oai3Operation);
        // Set up basic endpoint fields
        if (parameters.body) {
            oai3Operation.requestBody = getRequestBody(parameters.body && [parameters.body], visibility, examples);
        }
        const authReference = serviceAuth.operationsAuth.get(operation.operation);
        if (authReference) {
            oai3Operation.security = getEndpointSecurity(authReference);
        }
        if (isDeprecated(program, op)) {
            oai3Operation.deprecated = true;
        }
        attachExtensions(program, op, oai3Operation);
        return { operation: oai3Operation, path: fullPath, verb };
    }
    function getSharedResponses(operation, examples) {
        const responseMap = new Map();
        for (const op of operation.operations) {
            for (const response of op.responses) {
                const statusCodes = diagnostics.pipe(getOpenAPI3StatusCodes(program, response.statusCodes, op.operation));
                for (const statusCode of statusCodes) {
                    if (responseMap.has(statusCode)) {
                        responseMap.get(statusCode).push(response);
                    }
                    else {
                        responseMap.set(statusCode, [response]);
                    }
                }
            }
        }
        const result = {};
        for (const [statusCode, statusCodeResponses] of responseMap) {
            const dedupeResponses = deduplicateCommonResponses(statusCodeResponses);
            result[statusCode] = getResponseForStatusCode(operation, statusCode, dedupeResponses, examples);
        }
        return result;
    }
    function getResponses(operation, responses, examples) {
        const result = {};
        for (const response of responses) {
            for (const statusCode of diagnostics.pipe(getOpenAPI3StatusCodes(program, response.statusCodes, response.type))) {
                result[statusCode] = getResponseForStatusCode(operation, statusCode, [response], examples);
            }
        }
        return result;
    }
    function isBinaryPayload(body, contentType) {
        return (body.kind === "Scalar" &&
            body.name === "bytes" &&
            contentType !== "application/json" &&
            contentType !== "text/plain");
    }
    function getResponseForStatusCode(operation, statusCode, responses, examples) {
        const openApiResponse = {
            description: "",
        };
        const schemaMap = new Map();
        for (const response of responses) {
            const refUrl = getRef(program, response.type);
            if (refUrl) {
                return { $ref: refUrl };
            }
            if (response.description && response.description !== openApiResponse.description) {
                openApiResponse.description = openApiResponse.description
                    ? `${openApiResponse.description} ${response.description}`
                    : response.description;
            }
            emitResponseHeaders(openApiResponse, response.responses, response.type);
            emitResponseContent(operation, openApiResponse, response.responses, statusCode, examples, schemaMap);
            if (!openApiResponse.description) {
                openApiResponse.description = getResponseDescriptionForStatusCode(statusCode);
            }
        }
        return openApiResponse;
    }
    function emitResponseHeaders(obj, responses, target) {
        for (const data of responses) {
            if (data.headers && Object.keys(data.headers).length > 0) {
                obj.headers ??= {};
                // OpenAPI can't represent different headers per content type.
                // So we merge headers here, and report any duplicates unless they are identical
                for (const [key, value] of Object.entries(data.headers)) {
                    const headerVal = getResponseHeader(value);
                    const existing = obj.headers[key];
                    if (existing) {
                        if (!deepEquals(existing, headerVal)) {
                            diagnostics.add(createDiagnostic({
                                code: "duplicate-header",
                                format: { header: key },
                                target: target,
                            }));
                        }
                        continue;
                    }
                    obj.headers[key] = headerVal;
                }
            }
        }
    }
    function emitResponseContent(operation, obj, responses, statusCode, examples, schemaMap = undefined) {
        schemaMap ??= new Map();
        for (const data of responses) {
            if (data.body === undefined) {
                continue;
            }
            obj.content ??= {};
            for (const contentType of data.body.contentTypes) {
                const contents = getBodyContentEntry(data.body, Visibility.Read, contentType, examples.responses[statusCode]?.[contentType]);
                if (schemaMap.has(contentType)) {
                    schemaMap.get(contentType).push(contents);
                }
                else {
                    schemaMap.set(contentType, [contents]);
                }
            }
            for (const [contentType, contents] of schemaMap) {
                if (contents.length === 1) {
                    obj.content[contentType] = contents[0];
                }
                else {
                    obj.content[contentType] = {
                        schema: { anyOf: contents.map((x) => x.schema) },
                    };
                }
            }
        }
    }
    function getResponseDescriptionForStatusCode(statusCode) {
        if (statusCode === "default") {
            return "An unexpected error response.";
        }
        return getStatusCodeDescription(statusCode) ?? "unknown";
    }
    function getResponseHeader(prop) {
        return getOpenAPIParameterBase(prop, Visibility.Read);
    }
    function callSchemaEmitter(type, visibility, ignoreMetadataAnnotations, contentType) {
        const result = emitTypeWithSchemaEmitter(type, visibility, ignoreMetadataAnnotations, contentType);
        switch (result.kind) {
            case "code":
                return result.value;
            case "declaration":
                return { $ref: `#/components/schemas/${result.name}` };
            case "circular":
                diagnostics.add(createDiagnostic({
                    code: "inline-cycle",
                    format: { type: getOpenAPITypeName(program, type, typeNameOptions) },
                    target: type,
                }));
                return {};
            case "none":
                return {};
        }
    }
    function getSchemaValue(type, visibility, contentType) {
        const result = emitTypeWithSchemaEmitter(type, visibility, false, contentType);
        switch (result.kind) {
            case "code":
            case "declaration":
                return result.value;
            case "circular":
                diagnostics.add(createDiagnostic({
                    code: "inline-cycle",
                    format: { type: getOpenAPITypeName(program, type, typeNameOptions) },
                    target: type,
                }));
                return {};
            case "none":
                return {};
        }
    }
    function emitTypeWithSchemaEmitter(type, visibility, ignoreMetadataAnnotations, contentType) {
        if (!metadataInfo.isTransformed(type, visibility)) {
            visibility = Visibility.Read;
        }
        contentType = contentType === "application/json" ? undefined : contentType;
        return schemaEmitter.emitType(type, {
            referenceContext: {
                visibility,
                serviceNamespaceName: serviceNamespaceName,
                ignoreMetadataAnnotations: ignoreMetadataAnnotations ?? false,
                contentType,
            },
        });
    }
    function getBodyContentEntry(body, visibility, contentType, examples) {
        const isBinary = isBinaryPayload(body.type, contentType);
        if (isBinary) {
            return { schema: { type: "string", format: "binary" } };
        }
        const oai3Examples = examples && getExampleOrExamples(program, examples);
        switch (body.bodyKind) {
            case "single":
                return {
                    schema: getSchemaForSingleBody(body.type, visibility, body.isExplicit && body.containsMetadataAnnotations, contentType.startsWith("multipart/") ? contentType : undefined),
                    ...oai3Examples,
                };
            case "multipart":
                return {
                    ...getBodyContentForMultipartBody(body, visibility, contentType),
                    ...oai3Examples,
                };
        }
    }
    function getSchemaForSingleBody(type, visibility, ignoreMetadataAnnotations, multipart) {
        const effectiveType = metadataInfo.getEffectivePayloadType(type, visibility);
        return callSchemaEmitter(effectiveType, visibility, ignoreMetadataAnnotations, multipart ?? "application/json");
    }
    function getBodyContentForMultipartBody(body, visibility, contentType) {
        const properties = {};
        const requiredProperties = [];
        const encodings = {};
        for (const [partIndex, part] of body.parts.entries()) {
            const partName = part.name ?? `part${partIndex}`;
            let schema = isBytesKeptRaw(program, part.body.type)
                ? { type: "string", format: "binary" }
                : getSchemaForSingleBody(part.body.type, visibility, part.body.isExplicit && part.body.containsMetadataAnnotations, part.body.type.kind === "Union" ? contentType : undefined);
            if (part.multi) {
                schema = {
                    type: "array",
                    items: schema,
                };
            }
            properties[partName] = schema;
            const encoding = resolveEncodingForMultipartPart(part, visibility, schema);
            if (encoding) {
                encodings[partName] = encoding;
            }
            if (!part.optional) {
                requiredProperties.push(partName);
            }
        }
        const schema = {
            type: "object",
            properties,
            required: requiredProperties,
        };
        const name = "name" in body.type && body.type.name !== ""
            ? getOpenAPITypeName(program, body.type, typeNameOptions)
            : undefined;
        if (name) {
            root.components.schemas[name] = schema;
        }
        const result = {
            schema: name ? { $ref: "#/components/schemas/" + name } : schema,
        };
        if (Object.keys(encodings).length > 0) {
            result.encoding = encodings;
        }
        return result;
    }
    function resolveEncodingForMultipartPart(part, visibility, schema) {
        const encoding = {};
        if (!isDefaultContentTypeForOpenAPI3(part.body.contentTypes, schema)) {
            encoding.contentType = part.body.contentTypes.join(", ");
        }
        const headers = part.headers;
        if (headers.length > 0) {
            encoding.headers = {};
            for (const header of headers) {
                const schema = getOpenAPIParameterBase(header.property, visibility);
                if (schema !== undefined) {
                    encoding.headers[header.options.name] = schema;
                }
            }
        }
        if (Object.keys(encoding).length === 0) {
            return undefined;
        }
        return encoding;
    }
    function isDefaultContentTypeForOpenAPI3(contentTypes, schema) {
        if (contentTypes.length === 0) {
            return false;
        }
        if (contentTypes.length > 1) {
            return false;
        }
        const contentType = contentTypes[0];
        switch (contentType) {
            case "text/plain":
                return schema.type === "string" || schema.type === "number";
            case "application/octet-stream":
                return ((schema.type === "string" && schema.format === "binary") ||
                    (schema.type === "array" &&
                        schema.items?.type === "string" &&
                        schema.items?.format === "binary"));
            case "application/json":
                return schema.type === "object";
        }
        return false;
    }
    function getParameter(parameter, visibility) {
        const param = {
            name: parameter.name,
            in: parameter.type,
            ...getOpenAPIParameterBase(parameter.param, visibility),
        };
        const attributes = getParameterAttributes(parameter);
        if (attributes === undefined) {
            param.schema = {
                type: "string",
            };
        }
        else {
            Object.assign(param, attributes);
        }
        return param;
    }
    function getEndpointParameters(parameters, visibility) {
        const result = [];
        for (const httpOpParam of parameters) {
            if (params.has(httpOpParam.param)) {
                result.push(params.get(httpOpParam.param));
                continue;
            }
            // eslint-disable-next-line @typescript-eslint/no-deprecated
            if (httpOpParam.type === "header" && isContentTypeHeader(program, httpOpParam.param)) {
                continue;
            }
            const param = getParameterOrRef(httpOpParam, visibility);
            if (param) {
                const existing = result.find((x) => !("$ref" in param) && !("$ref" in x) && x.name === param.name && x.in === param.in);
                if (existing && !("$ref" in param) && !("$ref" in existing)) {
                    mergeOpenApiParameters(existing, param);
                }
                else {
                    result.push(param);
                }
            }
        }
        return result;
    }
    function getRequestBody(bodies, visibility, examples) {
        if (bodies === undefined || bodies.every((x) => isVoidType(x.type))) {
            return undefined;
        }
        const requestBody = {
            required: bodies.every((body) => (body.property ? !body.property.optional : true)),
            content: {},
        };
        const schemaMap = new Map();
        for (const body of bodies.filter((x) => !isVoidType(x.type))) {
            const desc = body.property ? getDoc(program, body.property) : undefined;
            if (desc) {
                requestBody.description = requestBody.description
                    ? `${requestBody.description} ${desc}`
                    : desc;
            }
            const contentTypes = body.contentTypes.length > 0 ? body.contentTypes : ["application/json"];
            for (const contentType of contentTypes) {
                const existing = schemaMap.get(contentType);
                const entry = getBodyContentEntry(body, visibility, contentType, examples.requestBody[contentType]);
                if (existing) {
                    existing.push(entry);
                }
                else {
                    schemaMap.set(contentType, [entry]);
                }
            }
        }
        for (const [contentType, schemaArray] of schemaMap) {
            if (schemaArray.length === 1) {
                requestBody.content[contentType] = schemaArray[0];
            }
            else {
                requestBody.content[contentType] = {
                    schema: { anyOf: schemaArray.map((x) => x.schema).filter((x) => x !== undefined) },
                    encoding: schemaArray.find((x) => x.encoding)?.encoding,
                };
            }
        }
        return requestBody;
    }
    function getParameterOrRef(parameter, visibility) {
        if (isNeverType(parameter.param.type)) {
            return undefined;
        }
        let spreadParam = false;
        let property = parameter.param;
        if (property.sourceProperty) {
            // chase our sources all the way back to the first place this property
            // was defined.
            spreadParam = true;
            property = property.sourceProperty;
            while (property.sourceProperty) {
                property = property.sourceProperty;
            }
        }
        const refUrl = getRef(program, property);
        if (refUrl) {
            return {
                $ref: refUrl,
            };
        }
        if (params.has(property)) {
            return params.get(property);
        }
        const param = getParameter(parameter, visibility);
        // only parameters inherited by spreading from non-inlined type are shared in #/components/parameters
        if (spreadParam && property.model && !shouldInline(program, property.model)) {
            params.set(property, param);
            paramModels.add(property.model);
        }
        return param;
    }
    function getOpenAPIParameterBase(param, visibility) {
        const typeSchema = getSchemaForType(param.type, visibility);
        if (!typeSchema) {
            return undefined;
        }
        const schema = applyEncoding(program, param, applyIntrinsicDecorators(param, typeSchema), options);
        if (param.defaultValue) {
            schema.default = getDefaultValue(program, param.defaultValue, param);
        }
        // Description is already provided in the parameter itself.
        delete schema.description;
        const oaiParam = {
            required: !param.optional,
            description: getDoc(program, param),
            schema,
        };
        attachExtensions(program, param, oaiParam);
        return oaiParam;
    }
    function mergeOpenApiParameters(target, apply) {
        if (target.schema) {
            const schema = target.schema;
            if (schema.enum && apply.schema.enum) {
                schema.enum = [...new Set([...schema.enum, ...apply.schema.enum])];
            }
            target.schema = schema;
        }
        else {
            Object.assign(target, apply);
        }
        return target;
    }
    function getParameterAttributes(parameter) {
        switch (parameter.type) {
            case "header":
                return mapHeaderParameterFormat(parameter);
            case "query":
                return getQueryParameterAttributes(parameter);
            case "path":
                return getPathParameterAttributes(parameter);
        }
    }
    function getPathParameterAttributes(parameter) {
        if (parameter.allowReserved) {
            diagnostics.add(createDiagnostic({
                code: "path-reserved-expansion",
                target: parameter.param,
            }));
        }
        const attributes = {};
        if (parameter.explode) {
            attributes.explode = true;
        }
        switch (parameter.style) {
            case "label":
                attributes.style = "label";
                break;
            case "matrix":
                attributes.style = "matrix";
                break;
            case "simple":
                break;
            default:
                diagnostics.add(createDiagnostic({
                    code: "invalid-style",
                    format: { style: parameter.style, paramType: "path" },
                    target: parameter.param,
                }));
        }
        return attributes;
    }
    function getQueryParameterAttributes(parameter) {
        const attributes = {};
        if (parameter.explode !== true) {
            // For query parameters(style: form) the default is explode: true https://spec.openapis.org/oas/v3.0.2#fixed-fields-9
            attributes.explode = false;
        }
        // eslint-disable-next-line @typescript-eslint/no-deprecated
        switch (parameter.format) {
            case "ssv":
                return { style: "spaceDelimited", explode: false };
            case "pipes":
                return { style: "pipeDelimited", explode: false };
            case "csv":
            case "simple":
                return { explode: false };
            case undefined:
            case "multi":
            case "form":
                return attributes;
            default:
                diagnostics.add(createDiagnostic({
                    code: "invalid-format",
                    format: {
                        paramType: "query",
                        // eslint-disable-next-line @typescript-eslint/no-deprecated
                        value: parameter.format,
                    },
                    target: parameter.param,
                }));
                return undefined;
        }
    }
    function mapHeaderParameterFormat(parameter) {
        switch (parameter.format) {
            case undefined:
                return {};
            case "csv":
            case "simple":
                return { style: "simple" };
            default:
                diagnostics.add(createDiagnostic({
                    code: "invalid-format",
                    format: {
                        paramType: "header",
                        value: parameter.format,
                    },
                    target: parameter.param,
                }));
                return undefined;
        }
    }
    function emitParameters() {
        for (const [property, param] of params) {
            const key = getParameterKey(program, property, param, root.components.parameters, typeNameOptions);
            root.components.parameters[key] = { ...param };
            for (const key of Object.keys(param)) {
                delete param[key];
            }
            param.$ref = "#/components/parameters/" + encodeURIComponent(key);
        }
    }
    function emitSchemas(serviceNamespace) {
        if (!options.omitUnreachableTypes) {
            processUnreferencedSchemas();
        }
        const files = schemaEmitter.getSourceFiles();
        if (files.length > 0) {
            compilerAssert(files.length === 1, `Should only have a single file for now but got ${files.length}`);
            const schemas = root.components.schemas;
            const declarations = files[0].globalScope.declarations;
            for (const declaration of declarations) {
                schemas[declaration.name] = declaration.value;
            }
        }
        function processUnreferencedSchemas() {
            const addSchema = (type) => {
                if (isOrExtendsHttpFile(program, type)) {
                    return;
                }
                if (visibilityUsage.isUnreachable(type) &&
                    !paramModels.has(type) &&
                    !shouldInline(program, type)) {
                    callSchemaEmitter(type, Visibility.All);
                }
            };
            const skipSubNamespaces = isGlobalNamespace(program, serviceNamespace);
            navigateTypesInNamespace(serviceNamespace, {
                model: addSchema,
                scalar: addSchema,
                enum: addSchema,
                union: addSchema,
            }, { skipSubNamespaces });
        }
    }
    function emitTags() {
        for (const tag of tags) {
            root.tags.push({ name: tag });
        }
    }
    function getSchemaForType(type, visibility) {
        return callSchemaEmitter(type, visibility);
    }
    function attachExtensions(program, type, emitObject) {
        // Attach any OpenAPI extensions
        const extensions = getExtensions(program, type);
        if (extensions) {
            for (const key of extensions.keys()) {
                emitObject[key] = extensions.get(key);
            }
        }
    }
    function applyIntrinsicDecorators(typespecType, target) {
        const newTarget = { ...target };
        const docStr = getDoc(program, typespecType);
        if (docStr) {
            newTarget.description = docStr;
        }
        const formatStr = getFormat(program, typespecType);
        if (formatStr) {
            newTarget.format = formatStr;
        }
        const pattern = getPattern(program, typespecType);
        if (pattern) {
            newTarget.pattern = pattern;
        }
        const minLength = getMinLength(program, typespecType);
        if (minLength !== undefined) {
            newTarget.minLength = minLength;
        }
        const maxLength = getMaxLength(program, typespecType);
        if (maxLength !== undefined) {
            newTarget.maxLength = maxLength;
        }
        const minValue = getMinValue(program, typespecType);
        if (minValue !== undefined) {
            newTarget.minimum = minValue;
        }
        const minValueExclusive = getMinValueExclusive(program, typespecType);
        if (minValueExclusive !== undefined) {
            newTarget.minimum = minValueExclusive;
            newTarget.exclusiveMinimum = true;
        }
        const maxValue = getMaxValue(program, typespecType);
        if (maxValue !== undefined) {
            newTarget.maximum = maxValue;
        }
        const maxValueExclusive = getMaxValueExclusive(program, typespecType);
        if (maxValueExclusive !== undefined) {
            newTarget.maximum = maxValueExclusive;
            newTarget.exclusiveMaximum = true;
        }
        const minItems = getMinItems(program, typespecType);
        if (!target.minItems && minItems !== undefined) {
            newTarget.minItems = minItems;
        }
        const maxItems = getMaxItems(program, typespecType);
        if (!target.maxItems && maxItems !== undefined) {
            newTarget.maxItems = maxItems;
        }
        if (isSecret(program, typespecType)) {
            newTarget.format = "password";
        }
        const title = getSummary(program, typespecType);
        if (title) {
            newTarget.title = title;
        }
        const values = getKnownValues(program, typespecType);
        if (values) {
            return {
                oneOf: [newTarget, callSchemaEmitter(values, Visibility.Read, false, "application/json")],
            };
        }
        attachExtensions(program, typespecType, newTarget);
        return newTarget;
    }
    function applyExternalDocs(typespecType, target) {
        const externalDocs = getExternalDocs(program, typespecType);
        if (externalDocs) {
            target.externalDocs = externalDocs;
        }
    }
    function getOpenAPISecuritySchemes(httpAuthentications) {
        const schemes = {};
        for (const httpAuth of httpAuthentications) {
            const scheme = getOpenAPI3Scheme(httpAuth);
            if (scheme) {
                schemes[httpAuth.id] = scheme;
            }
        }
        return schemes;
    }
    function getOpenAPISecurity(authReference) {
        const security = authReference.options.map((authOption) => {
            const securityOption = {};
            for (const httpAuthRef of authOption.all) {
                switch (httpAuthRef.kind) {
                    case "noAuth":
                        // should emit "{}" as a security option https://github.com/OAI/OpenAPI-Specification/issues/14#issuecomment-297457320
                        continue;
                    case "oauth2":
                        securityOption[httpAuthRef.auth.id] = httpAuthRef.scopes;
                        continue;
                    default:
                        securityOption[httpAuthRef.auth.id] = [];
                }
            }
            return securityOption;
        });
        return security;
    }
    function getEndpointSecurity(authReference) {
        const security = getOpenAPISecurity(authReference);
        if (deepEquals(security, root.security)) {
            return undefined;
        }
        if (security.length > 0) {
            return security;
        }
        return undefined;
    }
    function getOpenAPI3Scheme(auth) {
        const scheme = getOpenAPI3SchemeInternal(auth);
        if (scheme) {
            attachExtensions(program, auth.model, scheme);
        }
        return scheme;
    }
    function getOpenAPI3SchemeInternal(auth) {
        switch (auth.type) {
            case "http":
                return { type: "http", scheme: auth.scheme, description: auth.description };
            case "apiKey":
                return { type: "apiKey", in: auth.in, name: auth.name, description: auth.description };
            case "oauth2":
                const flows = {};
                const scopes = [];
                for (const flow of auth.flows) {
                    scopes.push(...flow.scopes.map((x) => x.value));
                    flows[flow.type] = {
                        authorizationUrl: flow.authorizationUrl,
                        tokenUrl: flow.tokenUrl,
                        refreshUrl: flow.refreshUrl,
                        scopes: Object.fromEntries(flow.scopes.map((x) => [x.value, x.description ?? ""])),
                    };
                }
                return { type: "oauth2", flows, description: auth.description };
            case "openIdConnect":
                return {
                    type: "openIdConnect",
                    openIdConnectUrl: auth.openIdConnectUrl,
                    description: auth.description,
                };
            case "noAuth":
                return undefined;
            default:
                diagnostics.add(createDiagnostic({
                    code: "unsupported-auth",
                    format: { authType: auth.type },
                    target: currentService.type,
                }));
                return undefined;
        }
    }
}
function serializeDocument(root, fileType) {
    sortOpenAPIDocument(root);
    switch (fileType) {
        case "json":
            return prettierOutput(JSON.stringify(root, null, 2));
        case "yaml":
            return stringify(root, {
                singleQuote: true,
                aliasDuplicateObjects: false,
                lineWidth: 0,
            });
    }
}
function prettierOutput(output) {
    return output + "\n";
}
class ErrorTypeFoundError extends Error {
    constructor() {
        super("Error type found in evaluated TypeSpec output");
    }
}
function sortObjectByKeys(obj) {
    return Object.keys(obj)
        .sort()
        .reduce((sortedObj, key) => {
        sortedObj[key] = obj[key];
        return sortedObj;
    }, {});
}
function sortOpenAPIDocument(doc) {
    doc.paths = sortObjectByKeys(doc.paths);
    if (doc.components?.schemas) {
        doc.components.schemas = sortObjectByKeys(doc.components.schemas);
    }
    if (doc.components?.parameters) {
        doc.components.parameters = sortObjectByKeys(doc.components.parameters);
    }
}
//# sourceMappingURL=openapi.js.map