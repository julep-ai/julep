import { getEncode } from "@typespec/compiler";
import { ObjectBuilder } from "@typespec/compiler/emitter-framework";
import { getSchemaForStdScalars } from "./std-scalar-schemas.js";
export function applyEncoding(program, typespecType, target, options) {
    const encodeData = getEncode(program, typespecType);
    if (encodeData) {
        const newTarget = new ObjectBuilder(target);
        const newType = getSchemaForStdScalars(encodeData.type, options);
        newTarget.type = newType.type;
        // If the target already has a format it takes priority. (e.g. int32)
        newTarget.format = mergeFormatAndEncoding(newTarget.format, encodeData.encoding, newType.format);
        return newTarget;
    }
    return new ObjectBuilder(target);
}
function mergeFormatAndEncoding(format, encoding, encodeAsFormat) {
    switch (format) {
        case undefined:
            return encodeAsFormat ?? encoding ?? format;
        case "date-time":
            switch (encoding) {
                case "rfc3339":
                    return "date-time";
                case "unixTimestamp":
                    return "unixtime";
                case "rfc7231":
                    return "http-date";
                default:
                    return encoding;
            }
        case "duration":
            switch (encoding) {
                case "ISO8601":
                    return "duration";
                default:
                    return encodeAsFormat ?? encoding;
            }
        default:
            return encodeAsFormat ?? encoding ?? format;
    }
}
//# sourceMappingURL=encoding.js.map