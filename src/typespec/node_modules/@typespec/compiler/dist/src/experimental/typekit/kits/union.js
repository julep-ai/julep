import { ignoreDiagnostics } from "../../../core/diagnostics.js";
import { createRekeyableMap } from "../../../utils/misc.js";
import { defineKit } from "../define-kit.js";
import { decoratorApplication } from "../utils.js";
export const UnionKit = defineKit({
    union: {
        create(desc) {
            const union = this.program.checker.createType({
                kind: "Union",
                name: desc.name,
                decorators: decoratorApplication(desc.decorators),
                variants: createRekeyableMap(),
                get options() {
                    return Array.from(this.variants.values()).map((v) => v.type);
                },
                expression: desc.name === undefined,
                node: undefined,
            });
            if (Array.isArray(desc.variants)) {
                for (const variant of desc.variants) {
                    union.variants.set(variant.name, variant);
                    variant.union = union;
                }
            }
            else if (desc.variants) {
                for (const [name, value] of Object.entries(desc.variants)) {
                    union.variants.set(name, this.unionVariant.create({ name, type: this.literal.create(value) }));
                }
            }
            this.program.checker.finishType(union);
            return union;
        },
        is(type) {
            return type.kind === "Union";
        },
        isValidEnum(type) {
            for (const variant of type.variants.values()) {
                if (!this.literal.isString(variant.type) && !this.literal.isNumeric(variant.type)) {
                    return false;
                }
            }
            return true;
        },
        isExtensible(type) {
            const variants = Array.from(type.variants.values());
            if (variants.length === 0) {
                return false;
            }
            for (let i = 0; i < variants.length; i++) {
                let isCommon = true;
                for (let j = 0; j < variants.length; j++) {
                    if (i === j) {
                        continue;
                    }
                    const assignable = ignoreDiagnostics(this.program.checker.isTypeAssignableTo(variants[j].type, variants[i].type, type));
                    if (!assignable) {
                        isCommon = false;
                        break;
                    }
                }
                if (isCommon) {
                    return true;
                }
            }
            return false;
        },
    },
});
//# sourceMappingURL=union.js.map