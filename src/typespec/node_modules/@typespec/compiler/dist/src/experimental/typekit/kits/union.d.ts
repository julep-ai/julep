import type { Type, Union, UnionVariant } from "../../../core/types.js";
import { DecoratorArgs } from "../utils.js";
interface UnionDescriptor {
    /**
     * The name of the union. If name is provided, it is a union declaration.
     * Otherwise, it is a union expression.
     */
    name?: string;
    /**
     * Decorators to apply to the union.
     */
    decorators?: DecoratorArgs[];
    /**
     * The variants of the union. If a variant is a string, number, or boolean, it
     * will be converted to a union variant with the same name and type.
     */
    variants?: Record<string | symbol, string | number> | UnionVariant[];
}
export interface UnionKit {
    union: {
        /**
         * Create a union type.
         *
         * @param desc The descriptor of the union.
         */
        create(desc: UnionDescriptor): Union;
        /**
         * Check if the given `type` is a union.
         *
         * @param type The type to check.
         */
        is(type: Type): type is Union;
        /**
         * Check if the union is a valid enum. Specifically, this checks if the
         * union has a name (since there are no enum expressions), and whether each
         * of the variant types is a valid enum member value.
         *
         * @param type The union to check.
         */
        isValidEnum(type: Union): boolean;
        /**
         * Check if a union is extensible. Extensible unions are unions which contain a variant
         * that is a supertype of all the other types. This means that the subtypes of the common
         * supertype are known example values, but others may be present.
         * @param type The union to check.
         */
        isExtensible(type: Union): boolean;
    };
}
declare module "../define-kit.js" {
    interface TypekitPrototype extends UnionKit {
    }
}
export declare const UnionKit: void;
export {};
//# sourceMappingURL=union.d.ts.map