var _a;
import { compilerAssert } from "../core/diagnostics.js";
import { $ } from "./typekit/define-kit.js";
class StateMapRealmView {
    #realm;
    #parentState;
    #realmState;
    constructor(realm, realmState, parentState) {
        this.#realm = realm;
        this.#parentState = parentState;
        this.#realmState = realmState;
    }
    has(t) {
        return this.dispatch(t).has(t) ?? false;
    }
    set(t, v) {
        this.dispatch(t).set(t, v);
        return this;
    }
    get(t) {
        return this.dispatch(t).get(t);
    }
    delete(t) {
        return this.dispatch(t).delete(t);
    }
    forEach(cb, thisArg) {
        for (const item of this.entries()) {
            cb.call(thisArg, item[1], item[0], this);
        }
        return this;
    }
    get size() {
        // extremely non-optimal, maybe worth not offering it?
        return [...this.entries()].length;
    }
    clear() {
        this.#realmState.clear();
    }
    *entries() {
        for (const item of this.#realmState) {
            yield item;
        }
        for (const item of this.#parentState) {
            yield item;
        }
        return undefined;
    }
    *values() {
        for (const item of this.entries()) {
            yield item[1];
        }
        return undefined;
    }
    *keys() {
        for (const item of this.entries()) {
            yield item[0];
        }
        return undefined;
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    [Symbol.toStringTag] = "StateMap";
    dispatch(keyType) {
        if (this.#realm.hasType(keyType)) {
            return this.#realmState;
        }
        return this.#parentState;
    }
}
/** @experimental */
export class Realm {
    #program;
    // Type registry
    /**
     * Stores all types owned by this realm.
     */
    #types = new Set();
    /**
     * Stores types that are deleted in this realm. When a realm is active and doing a traversal, you will
     * not find this type in e.g. collections. Deleted types are mapped to `null` if you ask for it.
     */
    #deletedTypes = new Set();
    #stateMaps = new Map();
    key;
    constructor(program, description) {
        this.key = Symbol(description);
        this.#program = program;
        _a.#knownRealms.set(this.key, this);
    }
    stateMap(stateKey) {
        let m = this.#stateMaps.get(stateKey);
        if (!m) {
            m = new Map();
            this.#stateMaps.set(stateKey, m);
        }
        return new StateMapRealmView(this, m, this.#program.stateMap(stateKey));
    }
    clone(type) {
        compilerAssert(type, "Undefined type passed to clone");
        const clone = this.#cloneIntoRealm(type);
        $.type.finishType(clone);
        return clone;
    }
    remove(type) {
        this.#deletedTypes.add(type);
    }
    hasType(type) {
        return this.#types.has(type);
    }
    addType(type) {
        this.#types.add(type);
        _a.realmForType.set(type, this);
    }
    #cloneIntoRealm(type) {
        const clone = $.type.clone(type);
        this.#types.add(clone);
        _a.realmForType.set(clone, this);
        return clone;
    }
    static #knownRealms = new Map();
    static realmForKey(key, parentRealm) {
        return this.#knownRealms.get(key);
    }
    static realmForType = new Map();
}
_a = Realm;
//# sourceMappingURL=realm.js.map