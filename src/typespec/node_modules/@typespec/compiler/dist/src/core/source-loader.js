import { resolveModule, ResolveModuleError, } from "../module-resolver/module-resolver.js";
import { deepEquals, doIO, resolveTspMain } from "../utils/misc.js";
import { compilerAssert, createDiagnosticCollector } from "./diagnostics.js";
import { resolveTypeSpecEntrypointForDir } from "./entrypoint-resolution.js";
import { createDiagnostic } from "./messages.js";
import { isImportStatement, parse } from "./parser.js";
import { getDirectoryPath } from "./path-utils.js";
import { createSourceFile } from "./source-file.js";
import { NoTarget, SyntaxKind, } from "./types.js";
/**
 * Create a TypeSpec source loader. This will be able to resolve and load TypeSpec and JS files.
 * @param host Compiler host
 * @param options Loading options
 */
export async function createSourceLoader(host, options) {
    const diagnostics = createDiagnosticCollector();
    const tracer = options?.tracer;
    const seenSourceFiles = new Set();
    const sourceFileLocationContexts = new WeakMap();
    const sourceFiles = new Map();
    const jsSourceFiles = new Map();
    const loadedLibraries = new Map();
    async function importFile(path, locationContext, kind = "import") {
        const sourceFileKind = host.getSourceFileKind(path);
        switch (sourceFileKind) {
            case "js":
                await importJsFile(path, locationContext, NoTarget);
                break;
            case "typespec":
                await loadTypeSpecFile(path, locationContext, NoTarget);
                break;
            default:
                diagnostics.add(createDiagnostic({
                    code: kind === "import" ? "invalid-import" : "invalid-main",
                    target: NoTarget,
                }));
        }
    }
    return {
        importFile,
        importPath,
        resolution: {
            sourceFiles,
            jsSourceFiles,
            locationContexts: sourceFileLocationContexts,
            loadedLibraries: loadedLibraries,
            diagnostics: diagnostics.diagnostics,
        },
    };
    async function loadTypeSpecFile(path, locationContext, diagnosticTarget) {
        if (seenSourceFiles.has(path)) {
            return;
        }
        seenSourceFiles.add(path);
        const file = await doIO(host.readFile, path, (x) => diagnostics.add(x), {
            diagnosticTarget,
        });
        if (file) {
            sourceFileLocationContexts.set(file, locationContext);
            await loadTypeSpecScript(file);
        }
    }
    async function loadTypeSpecScript(file) {
        // This is not a diagnostic because the compiler should never reuse the same path.
        // It's the caller's responsibility to use unique paths.
        if (sourceFiles.has(file.path)) {
            throw new RangeError("Duplicate script path: " + file.path);
        }
        const script = parseOrReuse(file);
        for (const diagnostic of script.parseDiagnostics) {
            diagnostics.add(diagnostic);
        }
        sourceFiles.set(file.path, script);
        await loadScriptImports(script);
        return script;
    }
    function parseOrReuse(file) {
        if (options?.getCachedScript) {
            const old = options.getCachedScript(file);
            if (old?.file === file && deepEquals(old.parseOptions, options.parseOptions)) {
                return old;
            }
        }
        const script = parse(file, options?.parseOptions);
        host.parseCache?.set(file, script);
        return script;
    }
    async function loadScriptImports(file) {
        // collect imports
        const basedir = getDirectoryPath(file.file.path);
        await loadImports(file.statements.filter(isImportStatement).map((x) => ({ path: x.path.value, target: x })), basedir, getSourceFileLocationContext(file.file));
    }
    function getSourceFileLocationContext(sourcefile) {
        const locationContext = sourceFileLocationContexts.get(sourcefile);
        compilerAssert(locationContext, "SourceFile should have a declaration locationContext.");
        return locationContext;
    }
    async function loadImports(imports, relativeTo, locationContext) {
        // collect imports
        for (const { path, target } of imports) {
            await importPath(path, target, relativeTo, locationContext);
        }
    }
    async function importPath(path, target, relativeTo, locationContext = { type: "project" }) {
        const library = await resolveTypeSpecLibrary(path, relativeTo, target);
        if (library === undefined) {
            return;
        }
        if (library.type === "module") {
            loadedLibraries.set(library.manifest.name, {
                path: library.path,
                manifest: library.manifest,
            });
            tracer?.trace("import-resolution.library", `Loading library "${path}" from "${library.mainFile}"`);
            const metadata = computeModuleMetadata(library);
            locationContext = {
                type: "library",
                metadata,
            };
        }
        const importFilePath = library.type === "module" ? library.mainFile : library.path;
        const isDirectory = (await host.stat(importFilePath)).isDirectory();
        if (isDirectory) {
            await loadDirectory(importFilePath, locationContext, target);
            return;
        }
        return importFile(importFilePath, locationContext);
    }
    /**
     * resolves a module specifier like "myLib" to an absolute path where we can find the main of
     * that module, e.g. "/typespec/node_modules/myLib/main.tsp".
     */
    async function resolveTypeSpecLibrary(specifier, baseDir, target) {
        try {
            return await resolveModule(getResolveModuleHost(), specifier, {
                baseDir,
                directoryIndexFiles: ["main.tsp", "index.mjs", "index.js"],
                resolveMain(pkg) {
                    // this lets us follow node resolve semantics more-or-less exactly
                    // but using tspMain instead of main.
                    return resolveTspMain(pkg) ?? pkg.main;
                },
                conditions: ["typespec"],
                fallbackOnMissingCondition: true,
            });
        }
        catch (e) {
            if (e instanceof ResolveModuleError) {
                diagnostics.add(moduleResolutionErrorToDiagnostic(e, specifier, target));
                return undefined;
            }
            else {
                throw e;
            }
        }
    }
    async function loadDirectory(dir, locationContext, diagnosticTarget) {
        const mainFile = await resolveTypeSpecEntrypointForDir(host, dir, (x) => diagnostics.add(x));
        await loadTypeSpecFile(mainFile, locationContext, diagnosticTarget);
        return mainFile;
    }
    /**
     * Import the Javascript files decorator and lifecycle hooks.
     */
    async function importJsFile(path, locationContext, diagnosticTarget) {
        const sourceFile = jsSourceFiles.get(path);
        if (sourceFile !== undefined) {
            return sourceFile;
        }
        const file = diagnostics.pipe(await loadJsFile(host, path, diagnosticTarget));
        if (file !== undefined) {
            sourceFileLocationContexts.set(file.file, locationContext);
            jsSourceFiles.set(path, file);
        }
        return file;
    }
    function getResolveModuleHost() {
        return {
            realpath: host.realpath,
            stat: host.stat,
            readFile: async (path) => {
                const file = await host.readFile(path);
                return file.text;
            },
        };
    }
}
function computeModuleMetadata(module) {
    const metadata = {
        type: "module",
        name: module.manifest.name,
    };
    if (module.manifest.homepage) {
        metadata.homepage = module.manifest.homepage;
    }
    if (module.manifest.bugs?.url) {
        metadata.bugs = { url: module.manifest.bugs?.url };
    }
    if (module.manifest.version) {
        metadata.version = module.manifest.version;
    }
    return metadata;
}
export async function loadJsFile(host, path, diagnosticTarget) {
    const file = createSourceFile("", path);
    const diagnostics = [];
    const exports = await doIO(host.getJsImport, path, (x) => diagnostics.push(x), {
        diagnosticTarget,
        jsDiagnosticTarget: { file, pos: 0, end: 0 },
    });
    if (!exports) {
        return [undefined, diagnostics];
    }
    const node = {
        kind: SyntaxKind.JsSourceFile,
        id: {
            kind: SyntaxKind.Identifier,
            sv: "",
            pos: 0,
            end: 0,
            symbol: undefined,
            flags: 8 /* NodeFlags.Synthetic */,
        },
        esmExports: exports,
        file,
        namespaceSymbols: [],
        symbol: undefined,
        pos: 0,
        end: 0,
        flags: 0 /* NodeFlags.None */,
    };
    return [node, diagnostics];
}
export function moduleResolutionErrorToDiagnostic(e, specifier, target) {
    switch (e.code) {
        case "MODULE_NOT_FOUND":
            return createDiagnostic({ code: "import-not-found", format: { path: specifier }, target });
        case "INVALID_MODULE":
        case "INVALID_MODULE_EXPORT_TARGET":
            return createDiagnostic({
                code: "library-invalid",
                format: { path: specifier, message: e.message },
                target,
            });
        case "INVALID_MAIN":
            return createDiagnostic({
                code: "library-invalid",
                format: { path: specifier, message: e.message },
                target,
            });
        default:
            return createDiagnostic({ code: "import-not-found", format: { path: specifier }, target });
    }
}
//# sourceMappingURL=source-loader.js.map