import type { PackageJson } from "../types/package-json.js";
export interface ResolveModuleOptions {
    baseDir: string;
    /**
     * When resolution reach package.json returns the path to the file relative to it.
     * @default pkg.main
     */
    resolveMain?: (pkg: any) => string;
    /**
     * When resolution reach a directory without package.json look for those files to load in order.
     * @default `["index.mjs", "index.js"]`
     */
    directoryIndexFiles?: string[];
    /** List of conditions to match in package exports */
    readonly conditions?: string[];
    /**
     * If exports is defined ignore if the none of the given condition is found and fallback to using main field resolution.
     * By default it will throw an error.
     */
    readonly fallbackOnMissingCondition?: boolean;
}
export interface ResolveModuleHost {
    /**
     * Resolve the real path for the current host.
     */
    realpath(path: string): Promise<string>;
    /**
     * Get information about the given path
     */
    stat(path: string): Promise<{
        isDirectory(): boolean;
        isFile(): boolean;
    }>;
    /**
     * Read a utf-8 encoded file.
     */
    readFile(path: string): Promise<string>;
}
type ResolveModuleErrorCode = "MODULE_NOT_FOUND" | "INVALID_MAIN" | "INVALID_MODULE"
/** When an exports points to an invalid file. */
 | "INVALID_MODULE_EXPORT_TARGET";
export declare class ResolveModuleError extends Error {
    code: ResolveModuleErrorCode;
    constructor(code: ResolveModuleErrorCode, message: string);
}
export type ModuleResolutionResult = ResolvedFile | ResolvedModule;
export interface ResolvedFile {
    type: "file";
    path: string;
}
export interface ResolvedModule {
    type: "module";
    /**
     * Root of the package. (Same level as package.json)
     */
    path: string;
    /**
     * Resolved main file for the module.
     */
    mainFile: string;
    /**
     * Value of package.json.
     */
    manifest: PackageJson;
}
/**
 * Resolve a module
 * @param host
 * @param specifier
 * @param options
 * @returns
 * @throws {ResolveModuleError} When the module cannot be resolved.
 */
export declare function resolveModule(host: ResolveModuleHost, specifier: string, options: ResolveModuleOptions): Promise<ModuleResolutionResult>;
export {};
//# sourceMappingURL=module-resolver.d.ts.map