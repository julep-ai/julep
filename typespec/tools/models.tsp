import "../common";

using Common;

namespace Tools;

//
// TOOL MODELS
//

enum ToolType {
    /** A tool that emulates a function call */
    function,

    /** A tool that uses one of the Julep integrations */
    integration,

    /** A tool that uses a system resource */
    system,

    /** A tool that makes an API call */
    api_call,
}

/** The parameters the functions accepts, described as a JSON Schema object. */
alias FunctionParameters = Record<unknown>;

alias ToolOutput = Record<unknown>;

alias ToolChoiceOption = "auto" | "none" | NamedToolChoice;

/** Function definition */
model FunctionDef {
    /** DO NOT USE: This will be overriden by the tool name. Here only for compatibility reasons. */
    name?: null = null;

    /** Description of the function  */
    description?: identifierSafeUnicode;

    /** The parameters the function accepts */
    parameters?: FunctionParameters;

}

// TODO: We should use this model for all tools, not just functions and discriminate on the type
model Tool {
    /** Whether this tool is a `function`, `api_call`, `system` etc. (Only `function` tool supported right now) */
    type: ToolType = ToolType.function;

    /** Name of the tool (must be unique for this agent and a valid python identifier string )*/
    name: validPythonIdentifier;

    /** The function to call */
    function: FunctionDef;
    integration?: unknown;
    system?: unknown;
    api_call?: unknown;

    ...HasTimestamps;
    ...HasId;
}

model FunctionCallOption {
    /** The name of the function */
    name: string;
}

@discriminator("type")
model NamedToolChoice {
    /** Whether this tool is a `function`, `api_call`, `system` etc. (Only `function` tool supported right now) */
    type: ToolType;

    function?: FunctionCallOption;
    integration?: unknown;
    system?: unknown;
    api_call?: unknown;
}

model NamedFunctionChoice extends NamedToolChoice {
    type: ToolType.function;

    /** The function to call */
    function: FunctionCallOption;
}

model ToolResponse {
    @key id: uuid;

    /** The output of the tool */
    output: ToolOutput;
}

/** Payload for creating a tool */
@withVisibility("create")
model CreateToolRequest {
    ...Tool;
}

/** Payload for updating a tool */
@withVisibility("update")
model UpdateToolRequest {
    ...Tool;
}

/** Payload for patching a tool */
model PatchToolRequest is UpdateToolRequest {}

/** The response tool value generated by the model */
@discriminator("type")
model ChosenToolCall {
    /** Whether this tool is a `function`, `api_call`, `system` etc. (Only `function` tool supported right now) */
    type: ToolType;

    function?: FunctionCallOption;
    integration?: unknown;
    system?: unknown;
    api_call?: unknown;

    ...HasId;
}

model ChosenFunctionCall extends ChosenToolCall {
    type: ToolType.function;

    /** The function to call */
    function: FunctionCallOption;
}
