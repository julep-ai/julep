# Using Secrets in Julep

Julep provides a secure way to store and use sensitive information like API keys, tokens, and passwords without exposing them in your tasks or agent definitions. This guide explains how to leverage the secrets store to keep your sensitive data secure.

## What is the Secrets Store?

The secrets store is a secure database where sensitive information is stored with encryption. Secrets are:

- **Encrypted at rest** using bcrypt hashing
- **Scoped** to either a specific agent or a developer account
- **Never exposed** in task execution logs or outputs
- **Referenced indirectly** in your tasks using template variables

## Creating and Managing Secrets

Secrets can be created and managed through the Julep API. Each secret has:

- A unique name (used for reference)
- An encrypted value (the actual sensitive data)
- Optional description and metadata
- Scope (developer-wide or agent-specific)

### API Endpoints

The following endpoints are available for managing secrets:

#### Developer Secrets

- `POST /developers/{id}/secrets` - Create a developer-wide secret
- `GET /developers/{id}/secrets` - List all developer secrets
- `GET /developers/{developer_id}/secrets/{id}` - Get secret details (without the value)
- `PUT /developers/{developer_id}/secrets/{id}` - Update a secret
- `PATCH /developers/{developer_id}/secrets/{id}` - Partially update a secret
- `DELETE /developers/{developer_id}/secrets/{id}` - Delete a secret

#### Agent Secrets

- `POST /agents/{id}/secrets` - Create an agent-specific secret
- `GET /agents/{id}/secrets` - List all secrets available to an agent
- `GET /agents/{agent_id}/secrets/{id}` - Get agent secret details
- `PUT /agents/{agent_id}/secrets/{id}` - Update an agent secret
- `PATCH /agents/{agent_id}/secrets/{id}` - Partially update an agent secret
- `DELETE /agents/{agent_id}/secrets/{id}` - Delete an agent secret

## Using Secrets in Tasks

You can reference secrets in your tasks using the `secrets` field in tool definitions, particularly with API calls. Here's how:

### Example: API Call with Secret API Key

```yaml
tools:
- name: search_api
  type: api_call
  description: "Search for information using the API"
  api_call:
    method: GET
    url: "https://api.example.com/search"
    headers:
      Authorization: "$ f\"Bearer {secrets.API_KEY}\""
    params:
      q: "{{ query }}"
    secrets:
      API_KEY:
        name: "MY_SEARCH_API_KEY"
```

In this example:
1. A secret named `MY_SEARCH_API_KEY` is created in the secrets store
2. The task references this secret via `secrets.API_KEY` in a template expression
3. The actual API key value is only retrieved at execution time and never exposed in logs

### Available Only at Setup Time

Importantly, secrets are only available during the "setup time" of a task - when the tool is being prepared for execution. They are not available within steps themselves. This design ensures that sensitive information isn't accidentally leaked in intermediate results or logs.

### Key Benefits

- **Security**: Secret values are never visible in tasks, executions, or agent definitions
- **Separation of concerns**: Tasks define what they need without including actual credentials
- **Flexibility**: Secrets can be rotated or updated without modifying tasks
- **Scoping**: Developer-wide secrets can be used across multiple agents, while agent-specific secrets limit access

## Best Practices

1. **Use descriptive names**: Choose secret names that clearly indicate their purpose
2. **Rotate regularly**: Update sensitive values periodically using the API
3. **Limit scope**: Use agent-specific secrets when possible to limit exposure
4. **Add metadata**: Use the metadata field to store additional information about the secret, like expiration dates or usage notes

## Limitations

- Secrets are only available in template expressions at setup time, not during step execution
- Secret values are hashed before storage and cannot be retrieved in their original form
- Jinja2 template expressions must be used to reference secrets

By using the secrets store, you can build secure tasks and agents that interact with external services without exposing sensitive credentials in your code or configurations.